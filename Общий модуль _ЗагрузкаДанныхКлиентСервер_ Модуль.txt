/////////////////////////////////////////////////////////////////////////////////////
////////////////// Загрузка данных из других источников, выгрузка данных, обработка данных   /////////

//КАО_20231121 - версия 1.43
//	 Добавлены: ОткрытьВПриложении() - открытия указанного файла в связанном приложении
//КАО_20230817 - версия 1.42
//   Изменены: ПрочитатьТаблицуЗначенийИзXML() - Если передается дополнительный параметр ИспользоватьВнешнееПреобразованиеXSL=Истина, 
//						 вместо встроенного преобразования XML пытаемся использовать Msxml2.DOMDocument 
//   Добавлены: ПолучитьЭтотМодуль() - с учетом разных названий и 8.2
//КАО_20220819 - версия 1.41                                                                                                               
//   Изменены: ПолучитьИмяПоляТЗ() - если ничего не нашла - должна вернуть исходное имя
//	 ПреобразоватьКИдентификатору(), УдалитьНеиспользуемыеСимволы() // сейчас только буквы и цифры и символ подчеркивания
//КАО_20220808 - версия 1.40
//   Изменены: ПолучитьИмяПоляТЗ() - изменен поиск поля, ищет без учета регистра и символов, не являющихся разрешенными в идентификаторе 
//   					 ПреобразоватьКИдентификатору(), УдалитьНеиспользуемыеСимволы() // сейчас только буквы и цифры, подчеркивание только впереди 
//КАО_20220802 - версия 1.39
//   Изменены: ПреобразоватьКИдентификатору() - Упрощаем создание идентификатора - заносим только символы идентификатора	
//КАО_20220415 - версия 1.38
//   Изменены: ЧислоИзСтроки() - если в строке есть несколько разделителей - остается последний - новый вариант, совместимый с 8.2
//КАО_20220126 - версия 1.37
//   Изменены: ЧислоИзСтроки() - если в строке есть несколько разделителей - остается последний
//КАО_20210923 - версия 1.36
//   Изменены: РазобратьСтроку() - исправлена ошибка
//КАО_20210214 - версия 1.35
//   Изменены: JSON2XML_Массив - когда приходят только массивы - добавляются значения с атрибутами
//КАО_20200914 - версия 1.34
//   Изменены: ПолучитьИмяПоляТЗ, добавлены разрные варианты поиска поля в соответствии 
//КАО_20200814 - версия 1.33
//   Изменены: ДатаИзСтрокиСредствами1С(), ДатаИзСтроки(), если год < 100 - добавляется 2000
//КАО_20200430 - версия 1.32
//   Изменены: ВывестиТаблицуЗначенийВТабличныйДокумент(), можно передавать заголовок
//КАО_20200424 - версия 1.31
//   Изменены: Сообщить() заменено на СообщениеПользователю
//КАО_20200225 - версия 1.30
//   Изменены: ПроверитьИмяФайла - добавлена проверка на безопасный режим
//КАО_20190825 - версия 1.29
//   Изменены: Объект2XML, Список2XML 
//КАО_20190724 - версия 1.28
//   Изменены: JSON2XML - еще раз создана новая функция с рекурсивным вызовом, но json переводится в соответствие с помощью 1С 
//КАО_20190705 - версия 1.27
//   Изменены: JSON2XML - создана новая функция с рекурсивным вызовом для обработки массива
//КАО_20190524 - версия 1.26
//   Изменены: JSON2XML - исправлена ошибка при получении объекта
//КАО_20190322 - версия 1.25
//   Изменения для правильной работы в режиме совместимости 8.2
//КАО_20180710 - версия 1.24
//	 Изменены: JSON2XML - в XML записывается без анализа типа: ЗаписьXML.ЗаписатьТекст(XMLСтрока(ЧтениеJSON.ТекущееЗначение)) 
//   Изменены: ЧислоИзСтроки - пытается убрать пробелы из строки перед обработкой
//   Изменены: ДатаИзСтрокиСредствами1С - изменена начальная проверка формата  
//   Добавлены: ЗаполнитьЗначенияПоУмолчанию()
//КАО_20180524 - версия 1.23
//	 Изменены: JSON2XML - умеет разбирать цифровые ключи
//КАО_20180507 - версия 1.22
//	 Изменены: ПрочитатьДанныеИзXML
//   Исправлены ошибки
//КАО_20180418 - версия 1.21
//	 Изменены: Объект2XML
//	 Добавлены: Список2XML - для выгрузки в виде XML-строки в упрощенном формате списка объектов
//КАО_20180408 - версия 1.20
//	 Изменены: ПрочитатьДанныеИзXML
//   Исправлены ошибки
//КАО_20180403 - версия 1.19
//	 Добавлены: ДатаИзСтроки - для обработки даты, Объект2XML - для выгрузки в виде XML-строки в упрощенном формате
//КАО_20180130 - версия 1.18
//	 Изменены: JSON2XML - автоматически определяет, приходит файл или данные JSON
//КАО_20180113 - версия 1.17
//   Изменены: ПрочитатьТабличныйДокументИзExcel, учтено получение именованных областей с версии 8.3.10
//   Добавлен необязательный ключ в ДопДанные: СообщатьПрогресс
//КАО_20171128 - версия 1.16
//	 Добавлены: функция преобразования из JSON в XML 
//КАО_20171124 - версия 1.15
//	 Изменены: ПрочитатьПрогрессИСообщения
//КАО_20170910 - версия 1.14
//	 Изменены: ПрочитатьДанныеИзXML
//   Исправлены ошибки
//КАО_20170609 - версия 1.13
//	 Изменены: ПрочитатьТаблицуЗначенийИзТабличногоДокумента
//   В структуре ДопДанные может быть ключ: КоличествоКолонок, ограничивающий количество колонок в ТЗ 
//КАО_20170313 - версия 1.12
//	 Добавлены: ПрочитатьТаблицуЗначенийИзXML, ПрочитатьДанныеИзXML
//КАО_20170212 - версия 1.11
//	 Добавлена: ПрочитатьТаблицуЗначенийИзCSV
//КАО_20170209 - версия 1.10
//	 Изменены: ПолучитьИмяПоляТЗ. Если не найдено имя поля - ищем в верхнем регистре
//КАО_20170111 - версия 1.9
//	 Изменены: ПрочитатьТаблицуЗначенийИзМассива
//КАО_20161023 - версия 1.8
//	 Изменены: ВыбратьФайл
//КАО_20161012 - версия 1.7
//	 Изменены: СоздатьКолонки
//КАО_20161012 - версия 1.6
//	 Поддержка для работы в фоновых процессах. Изменены: ПрочитатьТабличныйДокументИзExcel, ПрочитатьТаблицуЗначенийИзТабличногоДокумента, ПрочитатьТаблицуЗначенийИзDBF
//КАО_20161010 - версия 1.5
//	 Переработана работа через COM. Добавлены: выгрузка в Excel через COM. Изменены: ПрочитатьДанныеИзExcelComObject, сопутствующие функции
//КАО_20160806 - версия 1.4
//   Изменены: ПрочитатьТабличныйДокументИзExcel
//КАО_20160801 - версия 1.3
//   Изменены: ВыбратьФайл, СоздатьКолонки
//КАО_20160725 - версия 1.2
//   Изменены: СоздатьКолонки: на форме таблица может быть с интерактивно созданными полями
//КАО_20160713 - версия 1.1 
//   Изменены: ВыбратьФайл, ВыбратьФайлЗавершение, добавлены: СоздатьКолонки
//КАО_20160627 - версия 1.0 


#Область КлиентскаяЧасть
/////// Клиентская часть /////////////////////////////

#Если Клиент Тогда

Функция ПолучитьЭтотМодуль()
	Объект = Неопределено;
	
	Попытка
	  Объект = Вычислить("ЭтотОбъект"); 
		возврат Объект;
	Исключение
	КонецПопытки;                                          
	
	// для 8.2
	Если Объект = Неопределено Тогда
		Попытка
		  Объект = Вычислить("прЗагрузкаДанныхКлиентСервер"); 
			возврат Объект;
		Исключение
		КонецПопытки; 
	КонецЕсли;
	
	Если Объект = Неопределено Тогда
		Попытка
		  Объект = Вычислить("_ЗагрузкаДанныхКлиентСервер"); 
			возврат Объект;
		Исключение
		КонецПопытки; 
	КонецЕсли;

	возврат  Неопределено ;
КонецФункции 
	
//&НаКлиенте

// Вызывает диалог выбора файла.
// 
// Параметры:
// 	ДопДанные - Структура - содержит ключи:
//     Форма - УправляемаяФорма - вызывающий объект.
//     ПутьКДанным          - Строка             - полное имя реквизита формы, содержащего текущее значение пути к файлу.
//                                                 Например "Путь" или "Объект.Путь".
//     Заголовок            - Строка             - Заголовок для диалога. (необяз)
//     ПолноеИмяФайла       - Строка             - начальное полное имя файла. (необяз)
//     Фильтр               - Строка             - Фильтр для выбора файлов (необяз)
//     ПредварительныйПросмотр	-	Булево	       - Предварительный просмотр (необяз)
// Пример: 
	//ДопДанные = новый Структура;
	//ДопДанные.Вставить("Форма",ЭтотОбъект); 
	//ДопДанные.Вставить("ПутьКДанным","Путь"); 
	//ДопДанные.Вставить("ПолноеИмяФайла",Путь); 
	//ДопДанные.Вставить("Фильтр","Excel (*.xls;*.xlsx;*.xlsm)|*.xls;*.xlsx;*.xlsm|"	+ "Все файлы (*.*)|*.*|");         

//  СтандартнаяОбработка - Булево             - для использования в обработчике "ПриНачалаВыбора". Будет заполнено
//                                                 значением Ложь.
//  ОповещениеЗавершения - ОписаниеОповещения - вызывается после успешного помещения нового значения в реквизит.
//
Процедура ВыбратьФайл(Знач ДопДанные,СтандартнаяОбработка = Ложь, ОповещениеЗавершения = Неопределено)   экспорт
	
	СтандартнаяОбработка = Ложь;
	
	Заголовок = СвойствоСтруктуры(ДопДанные, "Заголовок",  "Выберите файл с данными"); 
	ПолноеИмяФайла = СвойствоСтруктуры(ДопДанные, "ПолноеИмяФайла",  ""); 
	СтркИмени = РазложитьПолноеИмяФайла(ПолноеИмяФайла); 
	Фильтр = СвойствоСтруктуры(ДопДанные, "Фильтр",  "Все файлы (*.*)|*.*|"); 
	ПредварительныйПросмотр = СвойствоСтруктуры(ДопДанные, "ПредварительныйПросмотр",  Ложь); 
	
	Диалог = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);
	Диалог.Заголовок = Заголовок;
	Диалог.ПолноеИмяФайла = ПолноеИмяФайла;
	Диалог.Каталог = СтркИмени.Путь;
	Диалог.ПредварительныйПросмотр = ПредварительныйПросмотр;
	Диалог.Фильтр = Фильтр; 	// "Excel (*.xls;*.xlsx;*.xlsm)|*.xls;*.xlsx;*.xlsm|"	+ "Все файлы (*.*)|*.*|"; 
	
	ДопДанные2 = СкопироватьСтруктуру(ДопДанные); 
	ДопДанные2.Вставить("ОповещениеЗавершения",   ОповещениеЗавершения);
	
	Объект = ПолучитьЭтотМодуль();
	Диалог.Показать(Новый ОписаниеОповещения("ВыбратьФайлЗавершение", Объект, ДопДанные2));

КонецПроцедуры

//&НаКлиенте
Процедура ВыбратьФайлЗавершение(ВыбранныеФайлы, ДопДанные) Экспорт
	
	Если (ВыбранныеФайлы <> Неопределено) Тогда
		ПозТочки = Найти(ДопДанные.ПутьКДанным,"."); 
		Если ПозТочки>0 Тогда
			ПутьКОбъекту = Лев(ДопДанные.ПутьКДанным,ПозТочки-1); 
			ПутьКРекв    = Сред(ДопДанные.ПутьКДанным,ПозТочки+1); 
			ДопДанные.Форма[ПутьКОбъекту][ПутьКРекв] = ВыбранныеФайлы[0];    
		Иначе	
			ДопДанные.Форма[ДопДанные.ПутьКДанным] = ВыбранныеФайлы[0]; 
		КонецЕсли; 
		
		
		Если ДопДанные.ОповещениеЗавершения <> Неопределено Тогда
			ВыполнитьОбработкуОповещения(ДопДанные.ОповещениеЗавершения, ВыбранныеФайлы[0]);
		КонецЕсли;
	Иначе
	КонецЕсли;
	
КонецПроцедуры

// Вызывает диалог выбора каталога.
// 
// Параметры:
// 	ДопДанные - Структура - содержит ключи:
//     Форма - УправляемаяФорма - вызывающий объект.
//     ПутьКДанным          - Строка             - полное имя реквизита формы, содержащего текущее значение пути к файлу.
//                                                 Например "Путь" или "Объект.Путь".
//     Заголовок            - Строка             - Заголовок для диалога. (необяз)
//     Каталог              - Строка             - начальное полное имя файла. (необяз)
// Пример: 
	//ДопДанные = новый Структура;
	//ДопДанные.Вставить("Форма",ЭтотОбъект); 
	//ДопДанные.Вставить("ПутьКДанным","Путь"); 
	//ДопДанные.Вставить("Каталог",Путь); 

//  СтандартнаяОбработка - Булево             - для использования в обработчике "ПриНачалаВыбора". Будет заполнено
//                                                 значением Ложь.
//  ОповещениеЗавершения - ОписаниеОповещения - вызывается после успешного помещения нового значения в реквизит.
//
Процедура ВыбратьКаталог(Знач ДопДанные,СтандартнаяОбработка = Ложь, ОповещениеЗавершения = Неопределено)   экспорт
	
	СтандартнаяОбработка = Ложь;
	
	Заголовок = СвойствоСтруктуры(ДопДанные, "Заголовок",  "Выберите каталог с данными"); 
	Каталог = СвойствоСтруктуры(ДопДанные, "Каталог",  ""); 
	
	Диалог = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.ВыборКаталога);
	Диалог.Заголовок = Заголовок;
	Диалог.Каталог = Каталог;
	
	ДопДанные2 = СкопироватьСтруктуру(ДопДанные); 
	ДопДанные2.Вставить("ОповещениеЗавершения",   ОповещениеЗавершения);

	Объект = ПолучитьЭтотМодуль();
	Диалог.Показать(Новый ОписаниеОповещения("ВыбратьКаталогЗавершение", Объект, ДопДанные2));

КонецПроцедуры

//&НаКлиенте
Процедура ВыбратьКаталогЗавершение(ВыбранныеФайлы, ДопДанные) Экспорт
	
	Если (ВыбранныеФайлы <> Неопределено) Тогда
		ПозТочки = Найти(ДопДанные.ПутьКДанным,"."); 
		Если ПозТочки>0 Тогда
			ПутьКОбъекту = Лев(ДопДанные.ПутьКДанным,ПозТочки-1); 
			ПутьКРекв    = Сред(ДопДанные.ПутьКДанным,ПозТочки+1); 
			ДопДанные.Форма[ПутьКОбъекту][ПутьКРекв] = ВыбранныеФайлы[0];    
		Иначе	
			ДопДанные.Форма[ДопДанные.ПутьКДанным] = ВыбранныеФайлы[0]; 
		КонецЕсли; 
		
		
		Если ДопДанные.ОповещениеЗавершения <> Неопределено Тогда
			ВыполнитьОбработкуОповещения(ДопДанные.ОповещениеЗавершения, ВыбранныеФайлы[0]);
		КонецЕсли;
	Иначе
	КонецЕсли;
	
КонецПроцедуры

//&НаКлиенте           

// Процедура - Открывает переданный текст как файл в ассоциированном приложении
//
// Параметры:
//  ИмяФайла						 - 	 - 
// 	ДопДанные - Структура - содержит ключи:
//    ТекущийКаталог, ДождатьсяЗавершения - соответствуют ключам  НачатьЗапускПриложения()
//  СтандартнаяОбработка - Булево	 - будет устновлена в Ложь
//  ОповещениеЗавершения - ОписаниеОповещения - вызывается после успешного открытия
Процедура ОткрытьВПриложении(Знач ИмяФайла, СтандартнаяОбработка = Ложь, ДопДанные=Неопределено, ОповещениеЗавершения = Неопределено)  экспорт
	СтандартнаяОбработка = Ложь;

	Файл = Новый Файл(ИмяФайла);
	
	Если ТипЗнч(ДопДанные)=Тип("Структура") Тогда
		ДопДанные2 = СкопироватьСтруктуру(ДопДанные); 
	Иначе		       
		ДопДанные2 = Новый Структура;
	КонецЕсли;
	ДопДанные2.Вставить("ОповещениеЗавершения",   ОповещениеЗавершения);
	ДопДанные2.Вставить("ИмяФайла",   ИмяФайла);
	
	
	Объект = ПолучитьЭтотМодуль();
	Файл.НачатьПроверкуСуществования(Новый ОписаниеОповещения("ОткрытьВПриложенииПроверкаСуществованияФайлаЗавершение", Объект, ДопДанные2));
	
КонецПроцедуры

//&НаКлиенте
Процедура ОткрытьВПриложенииПроверкаСуществованияФайлаЗавершение(Существует, ДополнительныеПараметры) Экспорт
	
	Если Существует Тогда
		ИмяФайла = ДополнительныеПараметры.ИмяФайла;
		ТекущийКаталог = СвойствоСтруктуры(ДополнительныеПараметры,"ТекущийКаталог","");
		ДождатьсяЗавершения = СвойствоСтруктуры(ДополнительныеПараметры,"ДождатьсяЗавершения",Ложь);
		
		Объект = ПолучитьЭтотМодуль();
		НачатьЗапускПриложения(Новый ОписаниеОповещения("ОткрытьВПриложенииЗавершение", _ЗагрузкаДанныхКлиентСервер, ДополнительныеПараметры), ИмяФайла, ТекущийКаталог, ДождатьсяЗавершения);
		
	КонецЕсли;

КонецПроцедуры

//&НаКлиенте
Процедура ОткрытьВПриложенииЗавершение(КодВозврата, ДополнительныеПараметры) Экспорт
	Если ДополнительныеПараметры.ОповещениеЗавершения <> Неопределено Тогда
		ВыполнитьОбработкуОповещения(ДополнительныеПараметры.ОповещениеЗавершения, КодВозврата);
	КонецЕсли;
КонецПроцедуры 


#КонецЕсли 

#КонецОбласти 

#Область Загрузка_COM


// Функция - Open excel
//  Открывает COM объект Excel
// Возвращаемое значение:
//   - Объект Excel или неопределено
//
Функция Open_Excel() экспорт
	попытка
		Excel = Новый COMОбъект("Excel.Application");
		Excel.Visible = 0;
		Excel.DisplayAlerts = Ложь;
		
		возврат Excel;
	Исключение
		Сообщение = Новый СообщениеПользователю; Сообщение.Текст = НСтр("ru = 'Ошибка. Невозможно создать объект Excel.Application' ")+ОписаниеОшибки(); Сообщение.Сообщить(); 
		Возврат Неопределено;
	КонецПопытки;
КонецФункции
 
// Функция - Close excel
//  Закрывает COM объект Excel
// Параметры:
//  Excel	 -  - COM объект Excel	
// 
// Возвращаемое значение:
//  булево - истина, если успешно
//
Функция Close_Excel(Excel) экспорт
	Excel.WorkBooks.Close(); 
	Excel.Application.Quit();
	Excel = 0;
	возврат  Истина;
КонецФункции

// Функция - Open work book
//  Открывает COM объект WorkBook
// Параметры:
//  Excel		 - 	 -  COM объект Excel
//  ИмяФайла - строка	 - имя файла
// 
// Возвращаемое значение:
//   - COM объект или неопределено
//
Функция Open_WorkBook(Excel,ИмяФайла) экспорт
	попытка
		WBook = Excel.WorkBooks.Open(ИмяФайла);
		возврат WBook;
	Исключение
		Сообщение = Новый СообщениеПользователю; Сообщение.Текст = НСтр("ru = 'Ошибка. Невозможно создать объект WorkBook' ")+ОписаниеОшибки(); Сообщение.Сообщить(); 
		Возврат Неопределено;
	КонецПопытки;
КонецФункции

// Функция - Save As work book
//  Записывает COM объект WorkBook
// Параметры:
//  WBook		 - 	 - COM объект
//  ИмяФайла - строка	 - Имя файла
// 
// Возвращаемое значение:
//  булево -  Истина, если успешно
//
Функция SaveAs_WorkBook(WBook,ИмяФайла) экспорт
	WBook.SaveAs(ИмяФайла); 
	возврат  Истина;
КонецФункции

// Функция - Save work book
//  Записывает COM объект WorkBook
// Параметры:
//  WBook		 - 	 - COM объект
// 
// Возвращаемое значение:
//  булево -  Истина, если успешно
Функция Save_WorkBook(WBook) экспорт
	WBook.Save(); 
	возврат  Истина;
КонецФункции

// Функция - Close work book
//  Закрывает COM объект WorkBook
// Параметры:
//  WBook		 - 	 - COM объект
// 
// Возвращаемое значение:
//  булево -  Истина, если успешно
Функция Close_WorkBook(WBook) экспорт
	WBook.Close(Ложь); // не нужно сохранять изменения
	возврат  Истина;
КонецФункции

// Функция - Open лист
//  Открывает COM объект Sheet Excel
// Параметры:
//  Excel		 - 	 -  COM объект Excel
//  ИмяЛиста - строка, число	 - имя листа или номер
// 
// Возвращаемое значение:
//   - COM объект или неопределено
//
Функция Open_Sheet(Excel,ИмяЛиста) экспорт
	попытка
		Лист = Excel.Sheets(ИмяЛиста);
		возврат Лист;
	Исключение
		Сообщение = Новый СообщениеПользователю; Сообщение.Текст = НСтр("ru = 'Ошибка. Невозможно создать лист Excel' ")+ОписаниеОшибки(); Сообщение.Сообщить(); 
		Возврат Неопределено;
	КонецПопытки;
КонецФункции


// Функция - Заполненный диапазон листа Excel
//
// Параметры:
//  Лист - 	 - лист Excel
// 
// Возвращаемое значение:
//  структура - структура с ключами RowCount,ColumnCount
//
Функция ПолучитьЗаполненныйДиапазон(Лист) экспорт
	xlLastCell = 11;
	ActiveCell = Лист.Cells.SpecialCells(xlLastCell);
	RowCount = ActiveCell.Row;
	ColumnCount = ActiveCell.Column;
	возврат  новый Структура("RowCount,ColumnCount",RowCount,ColumnCount); 	
КонецФункции


		
// Функция выводит в файл в формате Excel специально подготовленные данные в виде массива массивов. Открывает Excel как Com-object. Работает как на клиенте, так и на сервере. 
// Умеет обрабатывать файлы с паролем 
// Добавлен параметр ДопДанные для дополнительной обработки листа Excel, если это структура, у нее могут быть следующие ключи
// СниматьЗащиту (булево) - защищенные листы не могут считываться, Excel блокирует некоторые данные, например номер последней колонки/строки
// ПарольЗащищенныхЯчеек (строка) - пароль для снятия защиты
// УстанавливатьЗащиту (булево) - защищенные листы не могут считываться, Excel блокирует некоторые данные, например номер последней колонки/строки
// НовыйПарольЗащищенныхЯчеек (строка) - пароль для установки защиты
// Если ПутьИлиАдресВХранилище - это адрес в хранилище, то в ДопДанные должнен быть ключ ИмяФайла - для определения расширения 
//
// Параметры:
//  МассивКолонок       - массив массивов по колонкам, быстро получаемый из Excel (Range.Value) 
//  ПутьИлиАдресВХранилищеИлиCOMОбъект - имя файла Excel, в который необходимо записать данные или путь файла во временном хранилище или Com Объект Excel
//  НомерЛистаExcel     - номер листа книги Excel, из которого необходимо прочитать данные (также сработает имя)
//  НомерПервойСтроки   - номер первой строки листа книги Excel, из которой необходимо прочитать подписи 
//  НомерПервойКолонки   - номер первой колонки листа книги Excel, из которой необходимо прочитать подписи 
//
// Возвращаемое значение:
//  Истина, если данные записаны, Ложь - иначе
//
Функция ВывестиДанныеВExcelComObject(МассивКолонок, ПутьИлиАдресВХранилищеИлиCOMОбъект, Знач НомерЛистаExcel = 1, Знач НомерПервойСтроки = 1, Знач НомерПервойКолонки = 1, ДопДанные=Неопределено) Экспорт
	
	Если ТипЗнч(ПутьИлиАдресВХранилищеИлиCOMОбъект)=Тип("Строка") тогда
		ПутьИлиАдресВХранилище = ПутьИлиАдресВХранилищеИлиCOMОбъект;
		ИмяФайла = Неопределено; 
		Если НЕ ПроверитьИмяФайла(ПутьИлиАдресВХранилище,ДопДанные, ИмяФайла) Тогда
			возврат  Ложь;
		КонецЕсли; 
		
		Попытка
			Excel = Новый COMОбъект("Excel.Application");
			WBook = Excel.WorkBooks.Open(ИмяФайла);
			ExcelЛист = Excel.Sheets(НомерЛистаExcel);
		Исключение
			Сообщение = Новый СообщениеПользователю; Сообщение.Текст = НСтр("ru = 'Ошибка. Невозможно открыть объект Excel '")+ОписаниеОшибки(); Сообщение.Сообщить(); 
			Возврат ложь;
		КонецПопытки;
	Иначе // это COM объект
		Попытка
			Excel = ПутьИлиАдресВХранилищеИлиCOMОбъект;
			ExcelЛист = Excel.Sheets(НомерЛистаExcel);
		Исключение
			Сообщение = Новый СообщениеПользователю; Сообщение.Текст = НСтр("ru = 'Ошибка. Возможно неверно указан номер листа книги Excel. '")+ОписаниеОшибки(); Сообщение.Сообщить(); 
			Возврат ложь;
		КонецПопытки;
	КонецЕсли; 	
	
	//#Если Клиент Тогда
	//Состояние("Обработка файла Microsoft Excel...");
	//#КонецЕсли
	
	Если ТипЗнч(ДопДанные)=Тип("Структура") Тогда
		СниматьЗащиту=Неопределено;
		ДопДанные.Свойство("СниматьЗащиту",СниматьЗащиту);
		Если СниматьЗащиту=Истина Тогда
			Если ExcelЛист.ProtectContents = Истина Тогда
				ПарольЗащищенныхЯчеек=Неопределено;			
				ДопДанные.Свойство("ПарольЗащищенныхЯчеек",ПарольЗащищенныхЯчеек);
				ExcelЛист.Unprotect(ПарольЗащищенныхЯчеек);
			КонецЕсли; 	
		КонецЕсли; 
	КонецЕсли;
	
		//xlCalculationManual  = -4135
		//Excel.Application.Calculation = xlCalculationManual  
		//Excel.Application.ScreenUpdating = False  
		//Excel.Application.EnableEvents = False  
		//Excel.Application.CalculateBeforeSave = True
		//
	
	ColumnCount = НомерПервойКолонки-1+МассивКолонок.Количество();
	RowCount = НомерПервойСтроки-1+МассивКолонок[0].Количество(); 
	
	Если RowCount=НомерПервойСтроки И ColumnCount=НомерПервойКолонки тогда // это одна ячейка
		ExcelЛист.Cells(НомерПервойСтроки, НомерПервойКолонки).Value = МассивКолонок[0][0];
	Иначе
		Массив2 = Новый COMSafeArray(МассивКолонок,"VT_VARIANT");
		ExcelЛист.Range(ExcelЛист.Cells(НомерПервойСтроки, НомерПервойКолонки), ExcelЛист.Cells(RowCount, ColumnCount)).Value = Массив2;
	КонецЕсли; 
	
		//xlCalculationAutomatic=-4105
		//Excel.Application.Calculation = xlCalculationAutomatic  
		//Excel.Application.ScreenUpdating = True  
		//Excel.Application.EnableEvents = True  
	
	#Если Клиент Тогда
	Состояние();
	#КонецЕсли
	
	Если ТипЗнч(ПутьИлиАдресВХранилищеИлиCOMОбъект)=Тип("Строка") тогда // Объект Excel был создан
	
		WBook.Close(Ложь); // не нужно сохранять изменения
		Excel.WorkBooks.Close(); 
		Excel.Application.Quit();
		Excel = 0;
		
	КонецЕсли; 	
	
	Возврат Истина;
	
КонецФункции 
		

// Функция считывает в массив массивов данные из файла в формате Excel. Открывает Excel как Com-object. Работает как на клиенте, так и на сервере. Умеет обрабатывать файлы с паролем 
// Рассчитана скорее на частичное считывание данных на клиенте, либо для обработки сложных файлов 
// Добавлен параметр ДопДанные для дополнительной обработки листа Excel, если это структура, у нее могут быть следующие ключи
// СниматьЗащиту (булево) - защищенные листы не могут считываться, Excel блокирует некоторые данные, например номер последней колонки/строки
// ПарольЗащищенныхЯчеек (строка) - пароль для снятия защиты
// Если ПутьИлиАдресВХранилище - это адрес в хранилище, то в ДопДанные должнен быть ключ ИмяФайла - для определения расширения 
//
// Параметры:
//  МассивКолонок       - массив массивов по колонкам, быстро получаемый из Excel (Range.Value) 
//  ПутьИлиАдресВХранилищеИлиCOMОбъект - имя файла Excel, из которого необходимо прочитать данные или путь файла во временном хранилище или Com Объект Excel
//  НомерЛистаExcel     - номер листа книги Excel, из которого необходимо прочитать данные (также сработает имя)
//  НомерПервойСтроки   - номер первой строки листа книги Excel, из которой необходимо прочитать подписи 
//  НомерПервойКолонки   - номер первой колонки листа книги Excel, из которой необходимо прочитать подписи 
//  НомерПоследнейСтроки   - номер последней строки листа книги Excel, из которой необходимо прочитать подписи (0 - до конца)
//  НомерПоследнейКолонки   - номер последней колонки листа книги Excel, из которой необходимо прочитать подписи (0 - до конца)
//
// Возвращаемое значение:
//  Истина, если файл прочитан, Ложь - иначе
//
Функция ПрочитатьДанныеИзExcelComObject(МассивКолонок, ПутьИлиАдресВХранилищеИлиCOMОбъект, Знач НомерЛистаExcel = 1, Знач НомерПервойСтроки = 1, Знач НомерПервойКолонки = 1, Знач НомерПоследнейСтроки = 0, Знач НомерПоследнейКолонки = 0, ДопДанные=Неопределено) Экспорт
	
	Если ТипЗнч(ПутьИлиАдресВХранилищеИлиCOMОбъект)=Тип("Строка") тогда
		ПутьИлиАдресВХранилище = ПутьИлиАдресВХранилищеИлиCOMОбъект;
		ИмяФайла = Неопределено; 
		Если НЕ ПроверитьИмяФайла(ПутьИлиАдресВХранилище,ДопДанные, ИмяФайла) Тогда
			возврат  Ложь;
		КонецЕсли; 
		
		Попытка
			Excel = Новый COMОбъект("Excel.Application");
			WBook = Excel.WorkBooks.Open(ИмяФайла);
			ExcelЛист = Excel.Sheets(НомерЛистаExcel);
		Исключение
			Сообщение = Новый СообщениеПользователю; Сообщение.Текст = НСтр("ru = 'Ошибка. Невозможно открыть объект Excel '")+ОписаниеОшибки(); Сообщение.Сообщить(); 
			Возврат ложь;
		КонецПопытки;
	Иначе // это COM объект
		Попытка
			Excel = ПутьИлиАдресВХранилищеИлиCOMОбъект;
			ExcelЛист = Excel.Sheets(НомерЛистаExcel);
		Исключение
			Сообщение = Новый СообщениеПользователю; Сообщение.Текст = НСтр("ru = 'Ошибка. Возможно неверно указан номер листа книги Excel. '")+ОписаниеОшибки(); Сообщение.Сообщить(); 
			Возврат ложь;
		КонецПопытки;
	КонецЕсли; 	
	
	//#Если Клиент Тогда
	//Состояние("Обработка файла Microsoft Excel...");
	//#КонецЕсли
	
	Если ТипЗнч(ДопДанные)=Тип("Структура") Тогда
		СниматьЗащиту=Неопределено;
		ДопДанные.Свойство("СниматьЗащиту",СниматьЗащиту);
		Если СниматьЗащиту=Истина Тогда
			Если ExcelЛист.ProtectContents = Истина Тогда
				ПарольЗащищенныхЯчеек=Неопределено;			
				ДопДанные.Свойство("ПарольЗащищенныхЯчеек",ПарольЗащищенныхЯчеек);
				ExcelЛист.Unprotect(ПарольЗащищенныхЯчеек);
			КонецЕсли; 	
		КонецЕсли; 
	КонецЕсли;
	
	Стрк = ПолучитьЗаполненныйДиапазон(ExcelЛист);
	RowCount = Стрк.RowCount;
	ColumnCount = Стрк.ColumnCount;
	Если НомерПоследнейСтроки<>0 И НомерПоследнейСтроки<RowCount тогда 
		RowCount = НомерПоследнейСтроки;
	КонецЕсли; 	
	Если НомерПоследнейКолонки<>0 И НомерПоследнейКолонки<ColumnCount тогда 
		ColumnCount = НомерПоследнейКолонки;
	КонецЕсли; 	
	
	Если НомерПервойСтроки<=0 тогда 
		НомерПервойСтроки = 1;
	КонецЕсли; 
	
	Если RowCount=НомерПервойСтроки И ColumnCount=НомерПервойКолонки тогда // это одна ячейка
		ЗнчЯчейки = ExcelЛист.Cells(НомерПервойСтроки, НомерПервойКолонки).Value ;
		МассивКолонок = новый Массив(1,1); 
		МассивКолонок[0][0] = ЗнчЯчейки;
	Иначе
		arr     = ExcelЛист.Range(ExcelЛист.Cells(НомерПервойСтроки, НомерПервойКолонки), ExcelЛист.Cells(RowCount, ColumnCount)).Value;
		МассивКолонок             = arr.Выгрузить();
	КонецЕсли; 	
	
	#Если Клиент Тогда
	Состояние();
	#КонецЕсли
	
	Если ТипЗнч(ПутьИлиАдресВХранилищеИлиCOMОбъект)=Тип("Строка") тогда // Объект Excel был создан
	
		WBook.Close(Ложь); // не нужно сохранять изменения
		Excel.WorkBooks.Close(); 
		Excel.Application.Quit();
		Excel = 0;
		
	КонецЕсли; 	
	
	Возврат Истина;
	
КонецФункции 

// Функция считывает в табличный документ данные из файла в формате Excel. Открывает Excel как Com-object. Работает как на клиенте, так и на сервере. Умеет обрабатывать файлы с паролем 
/// Добавлен параметр ДопДанные для дополнительной обработки листа Excel, если это структура, у нее могут быть следующие ключи
/// СниматьЗащиту (булево) - защищенные листы не могут считываться, Excel блокирует некоторые данные, например номер последней колонки/строки
/// ПарольЗащищенныхЯчеек (строка) - пароль для снятия защиты
/// Если ПутьИлиАдресВХранилище - это адрес в хранилище, то в ДопДанные должнен быть ключ ИмяФайла - для определения расширения 
//
// Параметры:
//  ТабличныйДокумент  - ТабличныйДокумент, в который необходимо прочитать данные
//  ПутьИлиАдресВХранилищеИлиCOMОбъект - имя файла Excel, из которого необходимо прочитать данные или путь файла во временном хранилище или Com Объект Excel
//  НомерЛистаExcel    - номер листа книги Excel, из которого необходимо прочитать данные (также сработает имя)
//
// Возвращаемое значение:
//  Истина, если файл прочитан, Ложь - иначе
//
Функция ПрочитатьТабличныйДокументИзExcelComObject(ТабличныйДокумент, ПутьИлиАдресВХранилищеИлиCOMОбъект, НомерЛистаExcel = 1, ДопДанные=Неопределено) Экспорт
	Если ТипЗнч(ПутьИлиАдресВХранилищеИлиCOMОбъект)=Тип("Строка") тогда
		ПутьИлиАдресВХранилище = ПутьИлиАдресВХранилищеИлиCOMОбъект;
		ИмяФайла = Неопределено; 
		Если НЕ ПроверитьИмяФайла(ПутьИлиАдресВХранилище,ДопДанные, ИмяФайла) Тогда
			возврат  Ложь;
		КонецЕсли; 
		
		Попытка
			Excel = Новый COMОбъект("Excel.Application");
			WBook = Excel.WorkBooks.Open(ИмяФайла);
			ExcelЛист = Excel.Sheets(НомерЛистаExcel);
		Исключение
			Сообщение = Новый СообщениеПользователю; Сообщение.Текст = НСтр("ru = 'Ошибка. Невозможно открыть объект Excel '")+ОписаниеОшибки(); Сообщение.Сообщить(); 
			Возврат ложь;
		КонецПопытки;
	Иначе // это COM объект
		Попытка
			Excel = ПутьИлиАдресВХранилищеИлиCOMОбъект;
			ExcelЛист = Excel.Sheets(НомерЛистаExcel);
		Исключение
			Сообщение = Новый СообщениеПользователю; Сообщение.Текст = НСтр("ru = 'Ошибка. Возможно неверно указан номер листа книги Excel. '")+ОписаниеОшибки(); Сообщение.Сообщить(); 
			Возврат ложь;
		КонецПопытки;
	КонецЕсли; 	
	
	Если ТипЗнч(ДопДанные)=Тип("Структура") Тогда
		СниматьЗащиту=Неопределено;
		ДопДанные.Свойство("СниматьЗащиту",СниматьЗащиту);
		Если СниматьЗащиту=Истина Тогда
			Если ExcelЛист.ProtectContents = Истина Тогда
				ПарольЗащищенныхЯчеек=Неопределено;			
				ДопДанные.Свойство("ПарольЗащищенныхЯчеек",ПарольЗащищенныхЯчеек);
				ExcelЛист.Unprotect(ПарольЗащищенныхЯчеек);
			КонецЕсли; 	
		КонецЕсли; 
	КонецЕсли;
	
	ТабличныйДокумент.Очистить();
	
	xlLastCell = 11;
	ActiveCell = Excel.ActiveCell.SpecialCells(xlLastCell);
	RowCount = ActiveCell.Row;
	ColumnCount = ActiveCell.Column;
	Для Column = 1 По ColumnCount Цикл
		ТабличныйДокумент.Область("C" + Формат(Column, "ЧГ=")).ШиринаКолонки = ExcelЛист.Columns(Column).ColumnWidth;
	КонецЦикла;
	Для Row = 1 По RowCount Цикл
		
		Для Column = 1 По ColumnCount Цикл
			ТабличныйДокумент.Область("R" + Формат(Row, "ЧГ=") +"C" + Формат(Column, "ЧГ=")).СодержитЗначение = Истина ;
			ТабличныйДокумент.Область("R" + Формат(Row, "ЧГ=") +"C" + Формат(Column, "ЧГ=")).Значение = ExcelЛист.Cells(Row,Column).Value;
		КонецЦикла;
		
	КонецЦикла;
	
	Если ТипЗнч(ПутьИлиАдресВХранилищеИлиCOMОбъект)=Тип("Строка") тогда // Объект Excel был создан
	
		WBook.Close(Ложь); // не нужно сохранять изменения
		Excel.WorkBooks.Close(); 
		Excel.Application.Quit();
		Excel = 0;
		
	КонецЕсли; 	
	
	Возврат Истина;
	
КонецФункции 


//	Преобразует  массив массивов по колонкам в табличный документ.
//   
//  Такой массив получается при быстром чтении из Excel
// 
//  Функция работает как на клиенте, так и на сервере. 

//	Параметры: 
//  МассивКолонок - исходный массив
//  ТабличныйДокумент  - ТабличныйДокумент, в который необходимо прочитать данные
//
// Возвращаемое значение:
//  Истина, если массив колонок обработан, Ложь - иначе
Функция ПрочитатьТабличныйДокументИзМассива(ТабличныйДокумент, МассивКолонок, ДопДанные=Неопределено) Экспорт
	
	ТабличныйДокумент.Очистить();
	
	ColumnCount = МассивКолонок.Количество();
	RowCount = МассивКолонок[0].Количество(); 
	
	Для Row = 1 По RowCount Цикл
		
		Для Column = 1 По ColumnCount Цикл
			Обл = ТабличныйДокумент.Область("R" + Формат(Row, "ЧГ=") +"C" + Формат(Column, "ЧГ=")); 
			Обл.СодержитЗначение = Истина ;
			Обл.Значение = МассивКолонок[Column][Row];
		КонецЦикла;
		
	КонецЦикла;

КонецФункции 
	
#КонецОбласти 

#Область Загрузка_XML

//////////////////// Загрузка из XML (работает как на клиенте, так и на сервере)////////////////////////////////

// Функция считывает в массив массивов данные из файла в формате XML. Работает как на клиенте, так и на сервере. 
/// ПутьИлиАдресВХранилище - путь к файлу или адрес в хранилище

//  МассивКолонок       - массив массивов по колонкам
//  ПутиXPATH_ДляПолученияСтрок - массив путей, по которому через ФабрикаXDTO, получаются объекты XDTO, для последнего элемента массива вызывается функция ФабрикаXDTO.ПолучитьСписок()
//  ПутиXPATH_ДляПолученияКолонок - соответствие или список значений (если важна последовательность колонок), ключ соответствия (значение списка значений) - Имя свойства XDTO, значение соответствия (представление списка значений) - имя колонки    
//
//  ДопДанные - структура с доп.данными. Могут быть ключи: 
//    Кодировка - кодировка файла (по умолчанию неопределено)
//    ВозвращатьТекстОшибки - если истина текст ошибки возвращается в ключе ТекстОшибки
// Возвращаемое значение:
//  Истина, если файл прочитан, Ложь - иначе
Функция ПрочитатьДанныеИзXML(МассивКолонок, ПутьИлиАдресВХранилище, ПутиXPATH_ДляПолученияСтрок, ПутиXPATH_ДляПолученияКолонок, ДопДанные=Неопределено) Экспорт
	
	//Если  Поля = Неопределено Тогда
	//	Поля = новый Соответствие;
	//КонецЕсли; 
	//Если Типы=Неопределено Тогда
	//	Типы = новый Соответствие;
	//КонецЕсли; 
	
  ЭтоСтрока = Ложь;
	ВозвращатьТекстОшибки = Неопределено;
	Кодировка   = Неопределено;
	Если ТипЗнч(ДопДанные)=Тип("Структура") тогда
		ДопДанные.Свойство("Кодировка",Кодировка);
		ДопДанные.Свойство("ВозвращатьТекстОшибки",ВозвращатьТекстОшибки);
		ДопДанные.Свойство("ЭтоСтрока",ЭтоСтрока);
	Иначе
	КонецЕсли; 	                              

	ИмяФайла = Неопределено; 
	Если НЕ ПроверитьИмяФайла(ПутьИлиАдресВХранилище,Новый Структура("ИмяФайла,ЭтоСтрока",".XML",ЭтоСтрока), ИмяФайла) Тогда
		возврат  Ложь;
	КонецЕсли; 

		
	//КАО_180507 Кодировку нужно указывать только в исключительных случаях 
	Если Кодировка="UTF-8" ИЛИ Кодировка="UTF8" ИЛИ нрег(Кодировка)="windows-1251" Тогда
		Кодировка = Неопределено;
	КонецЕсли; 
	
	Фабрика = Новый ФабрикаXDTO;
	
	ЧтениеXML = новый ЧтениеXML(); 
	ЧтениеXML.ОткрытьФайл(ИмяФайла,,,Кодировка); 
	Рез = Фабрика.ПрочитатьXML(ЧтениеXML); 
	
	
	Для СЦ=0 по ПутиXPATH_ДляПолученияСтрок.ВГраница()  Цикл
		ПутьXPATH_ДляПолученияСтрок = ПутиXPATH_ДляПолученияСтрок[СЦ];
		Если СЦ=ПутиXPATH_ДляПолученияСтрок.ВГраница() тогда // последний элемент получает список
			Попытка
				Строки = Рез.ПолучитьСписок(ПутьXPATH_ДляПолученияСтрок); 
			Исключение
				Строки = новый Массив;
				попытка 
					Об = Рез.Получить(ПутьXPATH_ДляПолученияСтрок); 
					Строки.Добавить(Об);
				Исключение
					Если ВозвращатьТекстОшибки=Истина Тогда
						ДопДанные.Вставить("ТекстОшибки",НСтр("ru = 'Ошибка. Невозможно прочитать строки данных '")+ПутьXPATH_ДляПолученияСтрок+"  "+ОписаниеОшибки()); 
					Иначе	
						Сообщение = Новый СообщениеПользователю; Сообщение.Текст = НСтр("ru = 'Ошибка. Невозможно прочитать строки данных '")+ПутьXPATH_ДляПолученияСтрок+"  "+ОписаниеОшибки(); Сообщение.Сообщить(); 
					КонецЕсли; 
					возврат  Ложь;		
				КонецПопытки; 	
			КонецПопытки; 
		Иначе
			Попытка
				Рез = Рез.Получить(ПутьXPATH_ДляПолученияСтрок); 
			Исключение
				Если ВозвращатьТекстОшибки=Истина Тогда
					ДопДанные.Вставить("ТекстОшибки",НСтр("ru = 'Ошибка. Невозможно прочитать путь до строк данных '")+ПутьXPATH_ДляПолученияСтрок+"  "+ОписаниеОшибки()); 
				Иначе
					Сообщение = Новый СообщениеПользователю; Сообщение.Текст = НСтр("ru = 'Ошибка. Невозможно прочитать путь до строк данных '")+ПутьXPATH_ДляПолученияСтрок+"  "+ОписаниеОшибки(); Сообщение.Сообщить(); 
				КонецЕсли; 
				возврат  Ложь;		
			КонецПопытки; 
		КонецЕсли; 	
	КонецЦикла; 
	
	ВсегоКолонок = ПутиXPATH_ДляПолученияКолонок.Количество();
	
	МассивКолонок = новый Массив(ВсегоКолонок,1);
	
	СпКол = новый СписокЗначений;
	
	Н = 0;
	Для каждого Эл Из ПутиXPATH_ДляПолученияКолонок Цикл
		Если ТипЗнч(ПутиXPATH_ДляПолученияКолонок)=Тип("Соответствие") тогда 
			ПутьКол  = Эл.Ключ;
			ИмяКол   = Эл.Значение;
		Иначе
			ПутьКол  = Эл.Значение;
			ИмяКол   = Эл.Представление;
		КонецЕсли; 	
		СпКол.Добавить(ПутьКол,ИмяКол); 
		МассивКолонок[Н][0] = ИмяКол;
		Н = Н+1;
	КонецЦикла; 
	
	Для каждого Стр Из Строки Цикл
		
		Н = 0;
		Для каждого Эл Из СпКол Цикл  // сейчас уже точно список значений, чтобы совпало с шапкой
			ПутьКол  = Эл.Значение;
			Попытка
				Зн = Стр.Получить(ПутьКол);
				Если ТипЗнч(Зн)=Тип("ОбъектXDTO") Тогда    //КАО_171130 должно быть значение, но для пустого значения возращается ОбъектXDTO
					Зн = Неопределено;
				КонецЕсли; 
			Исключение
				Если ВозвращатьТекстОшибки=Истина Тогда
					ДопДанные.Вставить("ТекстОшибки", НСтр("ru = 'Ошибка. Невозможно получить поле данных '")+ПутьКол+"  "+ОписаниеОшибки()); 
				Иначе
					Сообщение = Новый СообщениеПользователю; Сообщение.Текст = НСтр("ru = 'Ошибка. Невозможно получить поле данных '")+ПутьКол+"  "+ОписаниеОшибки(); Сообщение.Сообщить(); 
				КонецЕсли; 
				возврат  Ложь;		
			КонецПопытки; 
			
			М = МассивКолонок[Н];
			М.Добавить(Зн);
			Н = Н+1;
		КонецЦикла; 
		
	КонецЦикла; 
	
	возврат  Истина;
КонецФункции 


#КонецОбласти 

#Область СервернаяЗагрузкаДанных

//////////////////// Загрузка из Excel и DBF (серверная часть)////////////////////////////////

#Если НЕ ТонкийКлиент и НЕ ВебКлиент Тогда
	
// Функция считывает в табличный документ данные из файла в формате Excel. Открывает Excel средствами 1С. Работает только на сервере. 
// Особенность работы 1С заключается в том, что в табличный документ считываются все листы, данные на разных листах разделяются горизонтальным разделителем страниц
// Поэтому, если на листе Excel нет переносов страниц - номер листа определяется достаточно точно 
/// НомерИмяЛистаExcel = неопределено - если не заполнено - считывает все листы, если номер > 0 - пытается разобрать содержимое, подсчитывая разделители страниц, если указано имя листа - пытается получить область (работает с 8.3.10)
/// Если ПутьИлиАдресВХранилище - это адрес в хранилище, то в ДопДанные должнен быть ключ ИмяФайла - для определения расширения 
//  необязательный ключ СпособЧтенияЗначений - "Текст" или "Значение" (по умолчанию текст)
//  необязательный ключ СообщатьПрогресс - булево
// Возвращаемое значение:
//  Истина, если файл прочитан, Ложь - иначе
Функция ПрочитатьТабличныйДокументИзExcel(ТабличныйДокумент, ПутьИлиАдресВХранилище, НомерИмяЛистаExcel = Неопределено, ДопДанные=Неопределено ) Экспорт
	//КАО_20160216 - подготовлена функция
	
	ИмяФайла = Неопределено; 
	Если НЕ ПроверитьИмяФайла(ПутьИлиАдресВХранилище,ДопДанные, ИмяФайла) Тогда
		возврат  Ложь;
	КонецЕсли; 
	
	ТабличныйДокумент.Очистить();
	
	СпособЧтенияЗначений = "Текст";
	Если ТипЗнч(ДопДанные)=Тип("Структура") И ДопДанные.Свойство("СпособЧтенияЗначений") Тогда
		Если ЗначениеЗаполнено(ДопДанные.СпособЧтенияЗначений)  Тогда
			СпособЧтенияЗначений = ДопДанные.СпособЧтенияЗначений;
		КонецЕсли; 
	КонецЕсли; 
	
	ТабличныйДокумент.Прочитать(ИмяФайла,СпособЧтенияЗначенийТабличногоДокумента[СпособЧтенияЗначений]); 
	
	Если СвойствоСтруктуры(ДопДанные,"СообщатьПрогресс",Ложь) тогда 
		СообщитьПрогресс(,"Получен табличный документ"); //выводится только в фоновом процессе
	КонецЕсли; 	

	ColumnCount = ТабличныйДокумент.ШиринаТаблицы ;
	Если ColumnCount=0 Тогда
		ТекстОшибки = "Не удалось получить табличный документ из Excel"; 
		//Если ДопДанные=Неопределено	Тогда ДопДанные = новый Структура;	КонецЕсли; ДопДанные.Вставить("ТекстОшибки",ТекстОшибки); 
		Сообщение = Новый СообщениеПользователю; Сообщение.Текст = ТекстОшибки; Сообщение.Сообщить(); 
		возврат  Ложь;
	КонецЕсли; 
	
	
	Если ТипЗнч(НомерИмяЛистаExcel)=Тип("Число") И НомерИмяЛистаExcel>0 Тогда
		Найдено = Ложь;
		НайдРазд = 0;
		НачСтрока = 1;
		Для СЦ=1 по ТабличныйДокумент.ВысотаТаблицы цикл
			Обл = ТабличныйДокумент.Область(СЦ,,СЦ,);     
			Если Обл.КонецСтраницы Тогда
				НайдРазд=НайдРазд+1;
				КонСтрока = СЦ;
				Если НайдРазд=НомерИмяЛистаExcel Тогда // найден номер листа
					ТабличныйДокумент = ТабличныйДокумент.ПолучитьОбласть(НачСтрока,,КонСтрока,);					
					Найдено = Истина;
					Прервать;
				Иначе // еще не найден номер листа
					НачСтрока = СЦ+1;
				КонецЕсли; 
			КонецЕсли; 
		КонецЦикла;
		Если Не Найдено Тогда // последний лист
			ТабличныйДокумент = ТабличныйДокумент.ПолучитьОбласть(НачСтрока,,СЦ,);					
		КонецЕсли; 
	КонецЕсли; 
	
	Если ТипЗнч(НомерИмяЛистаExcel)=Тип("Строка") И ЗначениеЗаполнено( НомерИмяЛистаExcel ) Тогда
		ТабличныйДокумент = ТабличныйДокумент.ПолучитьОбласть(НомерИмяЛистаExcel);					
	КонецЕсли; 
	
	Если СвойствоСтруктуры(ДопДанные,"СообщатьПрогресс",Ложь) тогда 
		СообщитьПрогресс(,"Обработан табличный документ"); //выводится только в фоновом процессе
	КонецЕсли; 	
	
	Возврат Истина;
	
КонецФункции 



///////////////////////////////////// серверная часть ///////////////////////////////

Функция ДобавитьКолонкуТЗ(ТЗ, Имя, Тип=Неопределено, Заголовок=Неопределено, Ширина=Неопределено) 
	// Версия от 20080619_1051
	// Добавляет в таблицу значений колонку, если этой колонки нет в этой таблице
	// Возвращает колонку ТЗ, найденную или добавленную
	Рет = ТЗ.Колонки.Найти(Имя);
	Если Рет=Неопределено Тогда
		Рет = ТЗ.Колонки.Добавить(Имя, Тип, Заголовок, Ширина);
	КонецЕсли;
	возврат Рет ;
КонецФункции

Функция ПрименитьТипыВТЗ(ТЗ,Типы) 
	// если есть описанные типы колонок - преобразуем данные
	Для каждого Эл из Типы цикл // переберем описанные типы полей
		Колонка = ТЗ.Колонки.Найти(Эл.Ключ);
		Если Колонка=Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		Если ТипЗнч(Эл.Значение)=Тип("ОписаниеТипов") Тогда
			ОТ = Эл.Значение;
		Иначе // передан тип значения	
			мПолей = новый Массив;
			мПолей.Добавить(Эл.Значение); 
			ОТ = новый ОписаниеТипов(мПолей);
		КонецЕсли; 
		Колонка.Имя = "_"+Эл.Ключ;
		ТЗ.Колонки.Вставить(ТЗ.Колонки.Индекс(Колонка),Эл.Ключ,ОТ,Колонка.Заголовок,Колонка.Ширина); 
		М = ТЗ.ВыгрузитьКолонку(Колонка); 
		ТЗ.ЗагрузитьКолонку(М,Эл.Ключ); 
		ТЗ.Колонки.Удалить(Колонка); 
	КонецЦикла;	
	возврат  Истина;
КонецФункции

// находит имя поля в специальном соответствии Поля
Функция ПолучитьИмяПоляТЗ(Поля, ИмяПоляВх, Найдено = Ложь)
	ИмяПоля = ИмяПоляВх;
	ИмяПоляСоот = Поля.Получить(ИмяПоля);
	Если ИмяПоляСоот<>Неопределено  Тогда // найдено поле 
		Найдено = Истина;
		возврат ИмяПоляСоот; 
	КонецЕсли; 
	
	ИмяПоляСоот = Поля.Получить(ВРЕГ(ИмяПоля)); // если не найдено поле - пытаемся найти имя в верхнем регистре
	Если ИмяПоляСоот<>Неопределено  Тогда // найдено поле 
		Найдено = Истина;
		возврат ИмяПоляСоот; 
	КонецЕсли; 
	
	//// подготовим имя поля без переносов строк
	//ИмяПоля = СтрЗаменить(ИмяПоля,Символы.Таб," "); 
	//ИмяПоля = СтрЗаменить(ИмяПоля,Символы.НПП," "); 
	//ИмяПоля = СтрЗаменить(ИмяПоля,Символы.ПС,""); 
	//ИмяПоля = СтрЗаменить(ИмяПоля,Символ(13),""); 
	//ИмяПоля = СтрЗаменить(ИмяПоля,Символ(10),"");         
	
	// подготовим имя поля без неиспользуемых символов
	ИмяПоля = УдалитьНеиспользуемыеСимволы(ИмяПоля); 
	
	ИмяПоляСоот = Поля.Получить(ИмяПоля);
	Если ИмяПоляСоот<>Неопределено  Тогда // найдено поле 
		Найдено = Истина;
		возврат ИмяПоляСоот; 
	КонецЕсли; 
	
	ИмяПоляСоот = Поля.Получить(ВРЕГ(ИмяПоля)); // если не найдено поле без переносов - пытаемся найти имя в верхнем регистре
	Если ИмяПоляСоот<>Неопределено  Тогда // найдено поле 
		Найдено = Истина;
		возврат ИмяПоляСоот; 
	КонецЕсли; 
	
	// Добавим копию соответствия Поля, в котором тоже хранятся упрощенные ключи, для старых данных
	ИмяПоля = СтрЗаменить(ИмяПоля,"_",""); // уберем символ идентификатора
	Если Не ПустаяСтрока(ИмяПоля) Тогда
		ПоляУпр = Новый Соответствие;
		Для каждого Эл Из Поля Цикл
			НовКлюч = Врег(УдалитьНеиспользуемыеСимволы(Эл.Ключ)); // сейчас только буквы и цифры
			НовКлюч = СтрЗаменить(НовКлюч,"_",""); // уберем символ идентификатора
			Если НовКлюч<>ВРЕГ(Эл.Ключ) Тогда
				ПоляУпр.Вставить(НовКлюч,Эл.Значение);				
			КонецЕсли;
		КонецЦикла;
		ИмяПоляСоот = ПоляУпр.Получить(ВРЕГ(ИмяПоля)); // ищем в новом соответствии
		Если ИмяПоляСоот<>Неопределено  Тогда // найдено поле 
			Найдено = Истина;
			возврат ИмяПоляСоот; 
		КонецЕсли; 
	КонецЕсли;
	
	//КАО_220819 Если ничего не нашли - должны вернуть начальное имя поля
	
	Найдено = Ложь;
	возврат ИмяПоляВх ; 
КонецФункции

// находит имя поля в специальном соответствии Типы
Функция ПолучитьТипПоляТЗ(Типы, ИмяПоля, Найдено = Ложь)
	ТипПоляСоот = Типы.Получить(ИмяПоля);
	Если ТипПоляСоот=Неопределено  Тогда
		Найдено = Ложь;
		
		МассивТипов = Новый Массив;
		МассивТипов.Добавить(Тип("Строка"));
		МассивТипов.Добавить(Тип("Число"));
		Знак = ДопустимыйЗнак.Любой;
		КвалификаторЧисла  = Новый КвалификаторыЧисла(20, 8, Знак);
		КвалификаторСтроки = Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная);
		
		ДопустимыеТипы = Новый ОписаниеТипов(МассивТипов,КвалификаторЧисла,КвалификаторСтроки);
		
		возврат  ДопустимыеТипы; 
	Иначе
		Найдено = Истина;
		возврат ТипПоляСоот; 
	КонецЕсли; 
КонецФункции


//  ТЗ - подготовленная таблица значений
//  ТабличныйДокумент - выводимый документ
//  ДопДанные - неопределено, структура - ключи: 
//		ТекстЗаголовка - текст заголовка отчета 
//
// Возвращаемое значение:
//  Истина, если табличный документ создан, Ложь - иначе
Функция ВывестиТаблицуЗначенийВТабличныйДокумент(ТЗ, ТабличныйДокумент, ДопДанные=Неопределено) Экспорт
	ТабличныйДокумент=новый ТабличныйДокумент;
	
	ТекстЗаголовка = СвойствоСтруктуры(ДопДанные,"ТекстЗаголовка",""); 
	
	Построитель = Новый ПостроительОтчета;
	Построитель.ИсточникДанных=Новый ОписаниеИсточникаДанных(ТЗ);       
	
	Построитель.ВыводитьПодвалТаблицы = Ложь;
	Построитель.ВыводитьПодвалОтчета = Ложь;
	Построитель.ВыводитьОбщиеИтоги = Ложь;
	Если ЗначениеЗаполнено(ТекстЗаголовка) тогда 
		Построитель.ВыводитьЗаголовокОтчета = Истина;
		Построитель.ТекстЗаголовка=ТекстЗаголовка;
	Иначе
		Построитель.ВыводитьЗаголовокОтчета = Ложь;
	КонецЕсли ;	
	Построитель.ОформитьМакет();
	Построитель.Выполнить();
	Построитель.Вывести(ТабличныйДокумент); 
	
	возврат  Истина;
КонецФункции


//	Преобразует таблицу значений в массив массивов по колонкам.
//   
//  каждая колонка записывается в массив, эти массивы хранится в новом массиве - для быстрой записи в Excel
// 
//	Может использоваться для передачи на клиента данных, полученных
//	на сервере в виде таблицы значений в том случае, если таблица
//	значений содержит только такие значения, которые могут
//  быть переданы на клиента.
//
//	Параметры: 
//    ТаблицаЗначений - ТаблицаЗначений.
//
//	Возвращаемое значение: 
//    Массив
//
Функция ВывестиТаблицуЗначенийВМассив(ТаблицаЗначений) Экспорт
	
	Массив = Новый Массив();
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		МассивКол =  ТаблицаЗначений.ВыгрузитьКолонку( Колонка ); 
		Массив.Добавить(МассивКол); 
	КонецЦикла;	
	Возврат Массив;
	
КонецФункции


//	Преобразует  массив массивов по колонкам в таблицу значений.
//   
//  Такой массив получается при быстром чтении из Excel
// 
//	Параметры: 
//  МассивКолонок - исходный массив
//  ТЗ - заполняемая ТаблицаЗначений.  
//
//  НомерСтрокиПодписей - номер строки, из которой необходимо прочитать подписи
//  НомерПервойСтрокиСДанными -  номер строки, на которой начинаются данные
//
//  Поля, Типы - соответствия с именами и типами полей
//  Поля: ключ - имя колонки в файле (лучше в верхнем регистре), значение - итоговое имя колонки    
//
//  Типы: ключ - итоговое имя колонки, значение - тип значения колонки
//
// Возвращаемое значение:
//  Истина, если массив массивов прочитан, Ложь - иначе
Функция ПрочитатьТаблицуЗначенийИзМассива(ТЗ, МассивКолонок, НомерСтрокиПодписей = 1, НомерПервойСтрокиСДанными=2, Поля=Неопределено, Типы=Неопределено, ДопДанные=Неопределено) Экспорт
	
	Если  Поля = Неопределено Тогда
		Поля = новый Соответствие;
	КонецЕсли; 
	Если Типы=Неопределено Тогда
		Типы = новый Соответствие;
	КонецЕсли; 
	
	Попытка
		ColumnCount = МассивКолонок.Количество();
		ОбщееКоличествоСтрок = МассивКолонок[0].Количество(); 
		
		ТЗНов = новый ТаблицаЗначений;
		
		СтруктураСуществующихИдентификаторов=новый структура();
		Для Column = 0 По ColumnCount-1 Цикл
			Если НомерСтрокиПодписей=0 Тогда // авто имя "Колонка001"
				Поле_Ex = "Колонка"+Формат(Column+1,"ЧЦ=3; ЧВН=; ЧГ=0"); 
			Иначе	
				Поле_Ex = МассивКолонок[Column][НомерСтрокиПодписей-1]; 
				Если ПустаяСтрока(Поле_Ex) Тогда //анализ пустого наименования
					Поле_Ex = "Колонка"+Формат(Column+1,"ЧЦ=3; ЧВН=; ЧГ=0");
				КонецЕсли; 
			КонецЕсли; 
			Поле_Пр = ПолучитьИмяПоляТЗ(Поля,Поле_Ex);
			Поле_Имя = ПреобразоватьКИдентификатору(Поле_Пр,СтруктураСуществующихИдентификаторов);
			ТЗНов.Колонки.Добавить(Поле_Имя,ПолучитьТипПоляТЗ(Типы,Поле_Имя),Поле_Пр); 
		КонецЦикла;
		
		Для Row = НомерПервойСтрокиСДанными По ОбщееКоличествоСтрок Цикл
			Стр = ТЗНов.Добавить();
		КонецЦикла;
			
		чК = 0 ; 
		Для Каждого вКолонка Из МассивКолонок Цикл
			Для СЦ=1 По НомерПервойСтрокиСДанными-1 Цикл
				вКолонка.Удалить(0);
			КонецЦикла; 
			ТЗНов.ЗагрузитьКолонку(вКолонка,чК);
			чК = чК+1;
		КонецЦикла;	
		
		Для каждого Колонка Из ТЗНов.Колонки Цикл
			ДобавитьКолонкуТЗ(ТЗ, Колонка.Имя, Колонка.ТипЗначения, Колонка.Заголовок) ; 
		КонецЦикла; 
		
		Для каждого СтрТЗНов Из ТЗНов Цикл
			СтрТЗ = ТЗ.Добавить();
			ЗаполнитьЗначенияСвойств(СтрТЗ, СтрТЗНов); 
		КонецЦикла; 
			
		возврат  Истина;
	Исключение
		Сообщение = Новый СообщениеПользователю; Сообщение.Текст = НСтр("ru = 'Ошибка. Невозможно заполнить таблицу значений' ")+ОписаниеОшибки(); Сообщение.Сообщить(); 
		возврат  Ложь;
	КонецПопытки;
	
КонецФункции 

//  ТабличныйДокумент - исходный документ
//  НомерСтрокиПодписей - номер строки, из которой необходимо прочитать подписи (если 0 - имена колонок формируются в формате "Колонка001")
//  НомерПервойСтрокиСДанными -  номер строки, на которой начинаются данные
//
//  Поля, Типы - соответствия с именами и типами полей
//  Поля: ключ - имя колонки в файле (лучше в верхнем регистре), значение - итоговое имя колонки    
//
//  Типы: ключ - итоговое имя колонки, значение - тип значения колонки
//  
//  В структуре ДопДанные может быть ключ: КоличествоКолонок, ограничивающий количество колонок в ТЗ 
//  необязательный ключ СообщатьПрогресс - булево
//
// Возвращаемое значение:
//  Истина, если табличный документ прочитан, Ложь - иначе
Функция ПрочитатьТаблицуЗначенийИзТабличногоДокумента(ТЗ, ТабличныйДокумент, НомерСтрокиПодписей = 1, НомерПервойСтрокиСДанными=2, Поля=Неопределено, Типы=Неопределено, ДопДанные=Неопределено) Экспорт
	
	Если  Поля = Неопределено Тогда
		Поля = новый Соответствие;
	КонецЕсли; 
	Если Типы=Неопределено Тогда
		Типы = новый Соответствие;
	КонецЕсли; 
	
	//ОписаниеКолонок = новый Структура;
	
	Макет = новый ТабличныйДокумент;
	
	Заголовки = Макет.ПолучитьОбласть("R1");
	
	КоличествоКолонок=999;
	Если ТипЗнч(ДопДанные)=Тип("Структура") И ДопДанные.Свойство("КоличествоКолонок") Тогда
		Если ЗначениеЗаполнено(ДопДанные.КоличествоКолонок)  Тогда
			КоличествоКолонок = ДопДанные.КоличествоКолонок;
		КонецЕсли; 
	КонецЕсли; 
	
	ColumnCount = Мин(ТабличныйДокумент.ШиринаТаблицы,КоличествоКолонок) ;
	
	СтруктураСуществующихИдентификаторов=новый структура();
	Для Column = 1 По ColumnCount Цикл
		Если НомерСтрокиПодписей=0 Тогда // авто имя "Колонка001"
			Поле_Ex = "Колонка"+Формат(Column,"ЧЦ=3; ЧВН=; ЧГ=0"); 
		Иначе	
			Яч=ТабличныйДокумент.Область(НомерСтрокиПодписей, Column);
			Если Яч.СодержитЗначение Тогда
				Поле_Ex=Строка(Яч.Значение);
			Иначе
				Поле_Ex=Яч.Текст;
			КонецЕсли;
			Если ПустаяСтрока(Поле_Ex) Тогда //анализ пустого наименования
				Поле_Ex = "Колонка"+Формат(Column,"ЧЦ=3; ЧВН=; ЧГ=0");
			КонецЕсли; 
		КонецЕсли; 
		Поле_Пр = ПолучитьИмяПоляТЗ(Поля,Поле_Ex);
		Поле_Имя = ПреобразоватьКИдентификатору(Поле_Пр,СтруктураСуществующихИдентификаторов);
		//ДобавитьОписаниеКолонкиТЗ(ОписаниеКолонок,Поле_Имя,ПолучитьТипПоляТЗ(Типы,Поле_Имя),Поле_Пр, Яч.ШиринаКолонки);
		
		Заголовки.Область(1,Column).Текст = Поле_Имя;
		//СоотвКол.Вставить(Column-1, Поле_Имя);
	КонецЦикла;
	
	Макет.Вывести(Заголовки);
	Макет.Вывести(ТабличныйДокумент.ПолучитьОбласть(НомерПервойСтрокиСДанными,1,ТабличныйДокумент.ВысотаТаблицы,ColumnCount)); 
	Обл = Макет.Область(); 
	
	Если СвойствоСтруктуры(ДопДанные,"СообщатьПрогресс",Ложь) тогда 
		СообщитьПрогресс(,"Обработан табличный документ для вывода в ТЗ"); //выводится только в фоновом процессе
	КонецЕсли; 	

	Построитель = Новый ПостроительЗапроса;
	Построитель.ИсточникДанных=Новый ОписаниеИсточникаДанных(Обл);       
	Построитель.Выполнить();
	ТЗ = Построитель.Результат.Выгрузить();
	
	Если СвойствоСтруктуры(ДопДанные,"СообщатьПрогресс",Ложь) тогда 
		СообщитьПрогресс(,"Табличный документ выводен в ТЗ"); //выводится только в фоновом процессе
	КонецЕсли; 	
	
	ПрименитьТипыВТЗ(ТЗ,Типы);
	
	возврат  Истина;
КонецФункции 


// Функция считывает в табличный документ данные из файла в формате Excel. Открывает Excel средствами 1С. Работает только на сервере. 
// Особенность работы 1С заключается в том, что в табличный документ считываются все листы, данные на разных листах разделяются горизонтальным разделителем страниц
// Поэтому, если на листе Excel нет переносов страниц - номер листа определяется достаточно точно 
// НомерИмяЛистаExcel = неопределено - если не заполнено - считывает все листы, если номер > 0 - пытается разобрать содержимое, подсчитывая разделители страниц, если указано имя листа - пытается получить область (работает с 8.3.10)
// Если ПутьИлиАдресВХранилище - это адрес в хранилище, то в ДопДанные должнен быть ключ ИмяФайла - для определения расширения 
//  необязательный ключ СпособЧтенияЗначений - "Текст" или "Значение" (по умолчанию текст)

//  В структуре ДопДанные может быть ключ: КоличествоКолонок, ограничивающий количество колонок в ТЗ 

//  НомерСтрокиПодписей - номер строки, из которой необходимо прочитать подписи
//  НомерПервойСтрокиСДанными -  номер строки, на которой начинаются данные
//
//  Поля, Типы - соответствия с именами и типами полей
//  Поля: ключ - имя колонки в файле, значение - итоговое имя колонки    
//
//  Типы: ключ - итоговое имя колонки, значение - тип значения колонки

// Возвращаемое значение:
//  Истина, если файл прочитан, Ложь - иначе
Функция ПрочитатьТаблицуЗначенийИзExcel(ТЗ, ПутьИлиАдресВХранилище, НомерИмяЛистаExcel = Неопределено, НомерСтрокиПодписей = 1, НомерПервойСтрокиСДанными=2, Поля=Неопределено, Типы=Неопределено, ДопДанные=Неопределено) Экспорт
	ТабличныйДокумент = новый ТабличныйДокумент;
	Рез = ПрочитатьТабличныйДокументИзExcel(ТабличныйДокумент, ПутьИлиАдресВХранилище, НомерИмяЛистаExcel, ДопДанные); 	
	Если НЕ Рез Тогда
		возврат  Ложь;
	КонецЕсли; 
	Рез = ПрочитатьТаблицуЗначенийИзТабличногоДокумента(ТЗ,ТабличныйДокумент,НомерСтрокиПодписей,НомерПервойСтрокиСДанными,Поля,Типы,ДопДанные); 
	возврат  Рез;
КонецФункции 


//////////////////////////////////////////////////////

Функция ВернутьТипИзDBF(Поле)
	Перем Тип1С, ТипДБФ, ДлинаПоля, ТочностьПоля ; 
	
	ТипДБФ = Поле.Тип ;   
	Если  ТипДБФ = "S" тогда // строка
		ДлинаПоля  = Поле.Длина ;
		Тип1С=ПолучитьОписаниеТиповСтроки(ДлинаПоля); 
	ИначеЕсли  ТипДБФ = "N" или ТипДБФ = "F"   тогда // число
		ДлинаПоля  = Поле.Длина ;
		ТочностьПоля = Поле.Точность;
		Тип1С=ПолучитьОписаниеТиповЧисла(ДлинаПоля,ТочностьПоля); 
	ИначеЕсли  ТипДБФ = "D"  тогда // дата
		Тип1С=ПолучитьОписаниеТиповДаты(ЧастиДаты.ДатаВремя); 
	ИначеЕсли  ТипДБФ = "L"  тогда // булево
		Тип1С=Новый ОписаниеТипов("Булево"); 
	КонецЕсли ;      
	
	возврат Тип1С ; 
КонецФункции 


// Функция считывает в таблицу значений данные из файла в формате dBase III (*.dbf)
//
// Параметры:
//  РезультатЗагрузки  - таблица значений, в которую необходимо прочитать данные
/// ПутьИлиАдресВХранилище - путь к файлу DBF или адрес в хранилище

//  Поля - соответствие с именами полей
//  Поля: ключ - имя колонки в файле (в верхнем регистре), значение - итоговое имя колонки    
//
// В ДопДанные может быть
//  необязательный ключ СообщатьПрогресс - булево
//
// Возвращаемое значение:
//  Истина, если файл прочитан, Ложь - иначе
//
Функция ПрочитатьТаблицуЗначенийИзDBF(РезультатЗагрузки, ПутьИлиАдресВХранилище,знач Кодировка=Неопределено, Поля=Неопределено, ДопДанные=Неопределено) Экспорт
	Если  Поля = Неопределено Тогда
		Поля = новый Соответствие;
	КонецЕсли; 
	
	ИмяФайла = Неопределено; 
	Если НЕ ПроверитьИмяФайла(ПутьИлиАдресВХранилище,Новый Структура("ИмяФайла",".DBF"), ИмяФайла) Тогда
		возврат  Ложь;
	КонецЕсли; 
	
	ВыбФайл = Новый Файл(ИмяФайла);
	
	ГСЧ = Новый ГенераторСлучайныхЧисел();
	Ч = Формат(ГСЧ.СлучайноеЧисло(100000, 999999),"ЧГ=0");
	ПР = Лев(ПользователиИнформационнойБазы.ТекущийПользователь().Имя,2);  
	ВремИмяФайла = КаталогВременныхФайлов()+ПР+Ч+".DBF"; 
	КопироватьФайл(ИмяФайла,ВремИмяФайла); 
	
	Если Кодировка=Неопределено Тогда
		Кодировка = "OEM";
	КонецЕсли; 
	
	Если ТипЗнч(Кодировка)=Тип("Строка") Тогда
		КодировкаХ = КодировкаXBase[Кодировка]; 
	Иначе  
		КодировкаХ = Кодировка;
	КонецЕсли; 
	
	База  = Новый XBase;
	База.Кодировка = КодировкаХ;
	Попытка
		База.ОткрытьФайл(ВремИмяФайла);
	Исключение
		Сообщение = Новый СообщениеПользователю; Сообщение.Текст = НСтр("ru = 'Ошибка открытия файла!' "); Сообщение.Сообщить(); 
		Возврат Ложь;
	КонецПопытки;
	
	Записей=База.КоличествоЗаписей();
	
	//РезультатЗагрузки = новый ТаблицаЗначений(); 
	//РезультатЗагрузки.Колонки.Добавить("НомерСтроки",новый ОписаниеТипов("Число"),"№",);
	//РезультатЗагрузки.Колонки.Добавить("Пометка",новый ОписаниеТипов("Булево"),"*",3);
	//РезультатЗагрузки.Колонки.Добавить("ЛицевойСчет",новый ОписаниеТипов("СправочникСсылка.ЛицевыеСчета"),"Лицевой счет",);
	//РезультатЗагрузки.Колонки.Добавить("Вид",ПолучитьОписаниеТиповСтроки("10"),"Вид");
	
	Для Каждого Поле из База.Поля Цикл
		Поле_Имя = ПолучитьИмяПоляТЗ(Поля,Поле.Имя); 
		ДобавитьКолонкуТЗ(РезультатЗагрузки,Поле_Имя,ВернутьТипИзDBF(Поле),Поле_Имя, Поле.Длина);
		//РезультатЗагрузки.Колонки.Добавить(Поле_Имя,ВернутьТипИзDBF(Поле),Поле_Имя, Поле.Длина);
	КонецЦикла;
	
	#Если Клиент Тогда
	Состояние("Для прерывания нажмите Ctrl+Break..."); 
	#КонецЕсли
	л1ПроцентЗаписей=Цел(Записей/100);
	лСлПроцент=л1ПроцентЗаписей;
	Для А=1 По Записей Цикл
		Если лСлПроцент<А Тогда
			Процент=Цел(А/Записей*100);
			лСлПроцент=лСлПроцент+л1ПроцентЗаписей;
			Если СвойствоСтруктуры(ДопДанные,"СообщатьПрогресс",Ложь) тогда 
				СообщитьПрогресс(Процент,"Обработано "+А+" записей"); //выводится только в фоновом процессе
			КонецЕсли; 	
		КонецЕсли; 
		
		//Состояние("Для прерывания нажмите Ctrl+Break. Запись "+А+" из "+Записей); 
		База.Перейти(А); 
		
		Стр=РезультатЗагрузки.Добавить();
		//Стр.Пометка = Истина;
		//Стр.НомерСтроки=А;
		
		Для каждого Поле Из База.Поля Цикл
			Поле_Имя = ПолучитьИмяПоляТЗ(Поля,Поле.Имя); 
			Стр[Поле_Имя]=База.ПолучитьЗначениеПоля(Поле.Имя);
		КонецЦикла; 
		
		//ОбработкаПрерыванияПользователя();
	КонецЦикла;
	База.ЗакрытьФайл();
	
	УдалитьФайлы(ВремИмяФайла); 
	
	Возврат Истина;
	
КонецФункции // ()

//////////////////// Загрузка из Excel и DBF ////////////////////////////////


//////////////////// Загрузка из CSV (серверная часть)////////////////////////////////

// Функция считывает в таблицу значений данные из файла в формате csv. Работает только на сервере. 
/// ПутьИлиАдресВХранилище - путь к файлу или адрес в хранилище

//  НомерСтрокиПодписей - номер строки, из которой необходимо прочитать подписи (если 0 - имена колонок формируются в формате "Колонка001")
//  НомерПервойСтрокиСДанными -  номер строки, на которой начинаются данные
//
//  Поля, Типы - соответствия с именами и типами полей
//  Поля: ключ - имя колонки в файле, значение - итоговое имя колонки    
//
//  Типы: ключ - итоговое имя колонки, значение - тип значения колонки
//  
//  ДопДанные - структура с доп.данными. Могут быть ключи: 
//    Кодировка - кодировка файла (по умолчанию ANSI)
//    Разделитель - разделитель полей (по умолчанию ';')
// Возвращаемое значение:
//  Истина, если файл прочитан, Ложь - иначе
Функция ПрочитатьТаблицуЗначенийИзCSV(ТЗ, ПутьИлиАдресВХранилище, НомерСтрокиПодписей = 1, НомерПервойСтрокиСДанными=2, Поля=Неопределено, Типы=Неопределено, ДопДанные=Неопределено) Экспорт
	
	ИмяФайла = Неопределено; 
	Если НЕ ПроверитьИмяФайла(ПутьИлиАдресВХранилище,Новый Структура("ИмяФайла",".CSV"), ИмяФайла) Тогда
		возврат  Ложь;
	КонецЕсли; 
	
	Если  Поля = Неопределено Тогда
		Поля = новый Соответствие;
	КонецЕсли; 
	Если Типы=Неопределено Тогда
		Типы = новый Соответствие;
	КонецЕсли; 
	
	Кодировка   = Неопределено;
	Разделитель = Неопределено;
	Если ТипЗнч(ДопДанные)=Тип("Структура") тогда
		ДопДанные.Свойство("Кодировка",Кодировка);
		ДопДанные.Свойство("Разделитель",Разделитель);
	Иначе
	КонецЕсли; 	
	
	Если Кодировка=Неопределено Тогда
		Кодировка = "ANSI";
	КонецЕсли; 
	
	Если Разделитель=Неопределено Тогда
		Разделитель = ";";
	КонецЕсли; 
	
	Если ТипЗнч(Кодировка)=Тип("Строка") Тогда
		КодировкаТекстаОбъекта = КодировкаТекста[Кодировка]; 
	Иначе
		КодировкаТекстаОбъекта = Кодировка;
	КонецЕсли; 	
	
	RegExp = Новый COMОбъект("VBScript.RegExp");
	RegExp.MultiLine  = Истина;
	RegExp.Global     = Истина;
	RegExp.IgnoreCase = Истина;
	
	Объект = новый ЧтениеТекста;
	Объект.Открыть(ИмяФайла,КодировкаТекстаОбъекта); 
	
	СтруктураСуществующихИдентификаторов=новый структура();
	ТЗНов = новый ТаблицаЗначений;
	
	ПерваяАнализируемаяСтрока = ?(НомерСтрокиПодписей=0,НомерПервойСтрокиСДанными,НомерСтрокиПодписей); 
	чС = 0 ; 
	Стр = Объект.ПрочитатьСтроку();
	Пока Стр <> Неопределено Цикл // строки читаются до символа перевода строки
		чС=чС+1 ; 
		#Если Клиент Тогда
		ОбработкаПрерыванияПользователя() ;
		#КонецЕсли 
		#Если Клиент Тогда
		Если чС%100=1 тогда	
			Состояние("Загружаем строки:" + чС);
		КонецЕсли; 
		#КонецЕсли 
		Если чС < ПерваяАнализируемаяСтрока тогда
			Стр = Объект.ПрочитатьСтроку();
			Продолжить;
		КонецЕсли; 	
		м = РазобратьСтроку(Стр,Разделитель,RegExp); 
		
		Если чС = ПерваяАнализируемаяСтрока тогда
			// добавим колонки ТЗ
			НомерКолонки = 0 ; 
			Для каждого элм Из м цикл
				НомерКолонки=НомерКолонки+1 ;
				
				Если НомерСтрокиПодписей=0 Тогда // авто имя "Колонка001"
					Поле_Ex = "Колонка"+Формат(НомерКолонки,"ЧЦ=3; ЧВН=; ЧГ=0"); 
				Иначе	
					Поле_Ex = элм; 
					Если ПустаяСтрока(Поле_Ex) Тогда //анализ пустого наименования
						Поле_Ex = "Колонка"+Формат(НомерКолонки,"ЧЦ=3; ЧВН=; ЧГ=0");
					КонецЕсли; 
				КонецЕсли; 
				Поле_Пр = ПолучитьИмяПоляТЗ(Поля,Поле_Ex);
				Поле_Имя = ПреобразоватьКИдентификатору(Поле_Пр,СтруктураСуществующихИдентификаторов);
				ТЗНов.Колонки.Добавить(Поле_Имя,ПолучитьТипПоляТЗ(Типы,Поле_Имя),Поле_Пр); 
			КонецЦикла;
		КонецЕсли; 	
		
		Если чС >= НомерПервойСтрокиСДанными тогда
			текСтрокаТЗ = ТЗНов.Добавить();
			НомерКолонки = 0 ; 
			Для каждого элм Из м цикл
				текСтрокаТЗ[НомерКолонки] = элм ;
				НомерКолонки=НомерКолонки+1 ;
			КонецЦикла;
		КонецЕсли; 	
		
		Стр = Объект.ПрочитатьСтроку();
	КонецЦикла;	
	
	Для каждого Колонка Из ТЗНов.Колонки Цикл
		ДобавитьКолонкуТЗ(ТЗ, Колонка.Имя, Колонка.ТипЗначения, Колонка.Заголовок) ; 
	КонецЦикла; 
	
	Для каждого СтрТЗНов Из ТЗНов Цикл
		СтрТЗ = ТЗ.Добавить();
		ЗаполнитьЗначенияСвойств(СтрТЗ, СтрТЗНов); 
	КонецЦикла; 
	
	возврат  Истина;
КонецФункции 


//=================== РАБОТА С REGEXP ========================================
// проверяет условия с помощью регулярных выражений, 
// если НЕ ТолькоПроверка - заменяет выражение с помощью шаблона ШаблонЗамены и возвращает в переменной ИтоговаяСтрока 
Функция ПроверитьУсловие(СтрокаПоиска,RegExp,ШаблонПоиска,ТолькоПроверка=Истина,ШаблонЗамены="",ИтоговаяСтрока="")
//	RegExp.Replace(СтрокаПоиска,ШаблонПоиска); 
	RegExp.Pattern = ШаблонПоиска;
	Найдено = RegExp.Test(СтрокаПоиска); 
	Если НЕ Найдено или ТолькоПроверка тогда 
		ИтоговаяСтрока=""; 
		возврат Найдено  ; 
	Иначе 
		ИтоговаяСтрока = RegExp.Replace(СтрокаПоиска,ШаблонЗамены); 
//		ИтоговаяСтрока = RegExp.Execute(СтрокаПоиска).Item(0).SubMatches.Item(ШаблонЗамены); 
		возврат Найдено  ; 
	КонецЕсли; 	
КонецФункции // ПроверитьУсловие()

Функция РазобратьСтроку(СтрокаПоиска, ВыбРазделительКолонок, RegExp)
	Если Найти(СтрокаПоиска,ВыбРазделительКолонок)=0 тогда СтрокаПоиска=СтрокаПоиска+ВыбРазделительКолонок; КонецЕсли ;
	НовСтрокаПоиска = СтрЗаменить(СтрокаПоиска,ВыбРазделительКолонок,"~SPC~"+ВыбРазделительКолонок);
  ШаблонПоиска    = ВыбРазделительКолонок+"(?=([^""]*""[^""]*"")*(?![^""]*""))"; 
	ШаблонЗамены    = "~REPL~" ; 
	ИтоговаяСтрока  = "" ; 
	ТолькоПроверка  = Ложь ; 
	УсловиеНайдено  = ПроверитьУсловие(НовСтрокаПоиска,RegExp,ШаблонПоиска,ТолькоПроверка,ШаблонЗамены,ИтоговаяСтрока); 
	
	Если УсловиеНайдено тогда
		// заменим кавычки по правилам CSV 
		ИтоговаяСтрока = СтрЗаменить(ИтоговаяСтрока,"""""","~'~"); 
		ИтоговаяСтрока = СтрЗаменить(ИтоговаяСтрока,""""  ,""   ); 
		ИтоговаяСтрока = СтрЗаменить(ИтоговаяСтрока,"~'~" ,"""" ); 
	КонецЕсли; 	
	ИтоговыйМассив  =  МассивИзСтроки(ИтоговаяСтрока,ШаблонЗамены); 
	НовыйМассив = Новый Массив() ; 
	Для каждого Эл  Из ИтоговыйМассив Цикл
		НовыйМассив.Добавить(СтрЗаменить(Эл,"~SPC~" ,"" )); 
	КонецЦикла; 
	
	возврат НовыйМассив;  
КонецФункции 

// Разбирает строку на две части: до подстроки разделителя и после.
//
// Параметры:
//  Стр          - разбираемая строка;
//  Разделитель  - подстрока-разделитель:
//  Режим        - 0 - разделитель в возвращаемые подстроки не включается;
//                 1 - разделитель включается в левую подстроку;
//                 2 - разделитель включается в правую подстроку.
//
// Возвращаемое значение:
//  Правая часть строки - до символа-разделителя.
// 
Функция ОтделитьРазделителем(ВыбСтр, Знач Разделитель, Режим=0) Экспорт

	ПраваяЧасть         = "";
	ПозРазделителя      = Найти(ВыбСтр, Разделитель);
	ДлинаРазделителя    = СтрДлина(Разделитель);
	Если ПозРазделителя > 0 Тогда
		ПраваяЧасть	 = Сред(ВыбСтр, ПозРазделителя + ?(Режим=2, 0, ДлинаРазделителя));
		ВыбСтр       = СокрЛП(Лев(ВыбСтр, ПозРазделителя - ?(Режим=1, -ДлинаРазделителя + 1, 1)));
	КонецЕсли;

	Возврат(ПраваяЧасть);

КонецФункции 
                                        
                                       
//Версия061011_1613  
// Преобразует значения из строки(или массива строк ) в новый массив, используя указанный разделитель
// Параметры:
//  Стр            - Разбираемая строка
//  Разделитель    - подстрока разделитель
//  Режим        - 0 - разделитель в возвращаемые подстроки не включается;
//                 1 - разделитель включается в левую подстроку;
//                 2 - разделитель включается в правую подстроку.
// ИспользоватьНесколькоРазделителей - если истина - считает, что в параметре Разделитель находится несколько разделителей, они используются по очереди
// Возвращаемое значение:
//  Массив значений
Функция МассивИзСтроки(Знач ВыбСтр, Разделитель=",", Режим=0, ИспользоватьНесколькоРазделителей=ложь) Экспорт
	Если типзнч(ВыбСтр)<>Тип("Массив") тогда
		ВыбМассив = Новый массив(); 
		ВыбМассив.Добавить(ВыбСтр); 
	Иначе	
		ВыбМассив = ВыбСтр ; 
	КонецЕсли; 	
	
	Если ИспользоватьНесколькоРазделителей и СтрДлина(СокрЛП(Разделитель))>1 тогда 
		Разделитель=СокрЛП(Разделитель) ; 
		
	  Массив = ВыбМассив; 
		Для СЦ=1 по СтрДлина(Разделитель) цикл
		 	Массив = МассивИзСтроки(Массив, сред(Разделитель,СЦ,1), Режим, ложь); 
		КонецЦикла;
		Возврат(Массив);
	Иначе	
		Массив      = Новый Массив;
		Для каждого ВыбСтр Из ВыбМассив Цикл
			ПраваяЧасть = ОтделитьРазделителем(ВыбСтр, Разделитель,Режим);
			Пока Не ПустаяСтрока(ВыбСтр) Цикл
				Массив.Добавить(СокрЛП(ВыбСтр));
				ВыбСтр         = ПраваяЧасть;
				ПраваяЧасть = ОтделитьРазделителем(ВыбСтр, Разделитель,Режим);
			КонецЦикла; 
		КонецЦикла; 
		Возврат(Массив);
	КонецЕсли; 	
КонецФункции 


//////////////////// Загрузка из XML (серверная часть)////////////////////////////////

// Функция считывает в ТЗ данные из файла в формате XML. Работает на сервере. 
// Сначала заполняет массив массивов, потом из него создает ТЗ
/// ПутьИлиАдресВХранилище - путь к файлу или адрес в хранилище

//  МассивКолонок       - массив массивов по колонкам
//  ПутьXPATH_ДляПолученияСтрок - 
//    1 вариант для простых файлов: массив путей, по которому через ФабрикаXDTO, получаются объекты XDTO, для последнего элемента массива вызывается функция ФабрикаXDTO.ПолучитьСписок()
//    2 вариант для сложных файлов: строка XPATH, для нее используется ПреобразованиеXSL
//  ПутиXPATH_ДляПолученияКолонок - соответствие, ключ - Путь XPATH, значение - имя колонки    
//
//  Поля, Типы - соответствия с именами и типами полей
//  Поля: ключ - имя колонки, указанное в соответствии ПутиXPATH_ДляПолученияКолонок, значение - итоговое имя колонки    
//
//  Типы: ключ - итоговое имя колонки, значение - тип значения колонки
//  
//  ДопДанные - структура с доп.данными. Могут быть ключи: 
//    Кодировка - кодировка файла (по умолчанию неопределено)
//    ИспользоватьВнешнееПреобразованиеXSL - булево - используется, если вызов осуществляется с сервера, используется Msxml2.DOMDocument
// Возвращаемое значение:
//  Истина, если файл прочитан, Ложь - иначе
Функция ПрочитатьТаблицуЗначенийИзXML(ТЗ, ПутьИлиАдресВХранилище, ПутьXPATH_ДляПолученияСтрок, ПутиXPATH_ДляПолученияКолонок, Поля=Неопределено, Типы=Неопределено, ДопДанные=Неопределено) Экспорт
	МассивКолонок = Неопределено;
	
	Если ТипЗнч(ПутьXPATH_ДляПолученияСтрок)=Тип("Массив") тогда // простой файл, строки описываются как свойства XDTO
		Рез = ПрочитатьДанныеИзXML(МассивКолонок,ПутьИлиАдресВХранилище, ПутьXPATH_ДляПолученияСтрок, ПутиXPATH_ДляПолученияКолонок,ДопДанные); 
		Если Не Рез тогда 
			возврат  Ложь;
		КонецЕсли; 
		Рез = ПрочитатьТаблицуЗначенийИзМассива(ТЗ,МассивКолонок,1,2,Поля,Типы,ДопДанные); 
		возврат  Рез;
	КонецЕсли; 	
	
	ИмяФайла = Неопределено; 
	Если НЕ ПроверитьИмяФайла(ПутьИлиАдресВХранилище,Новый Структура("ИмяФайла",".XML"), ИмяФайла) Тогда
		возврат  Ложь;
	КонецЕсли; 
	
	
	//Кодировка   = Неопределено;
	//Если ТипЗнч(ДопДанные)=Тип("Структура") тогда
	//	ДопДанные.Свойство("Кодировка",Кодировка);
	//Иначе
	//КонецЕсли; 	         
	
	//КАО_230519 Пока используем Msxml2.DOMDocument по умолчанию
	// если вызываем с сервера и в допданных есть условие
	ВнешняяКоманда="";
	Если СвойствоСтруктуры(ДопДанные,"ИспользоватьВнешнееПреобразованиеXSL",Истина)=Истина Тогда
		// макеты пока не проверям, используем Msxml2.DOMDocument 
		ВнешняяКоманда = "DOM";
		//Если Метаданные.ОбщиеМакеты.Найти("пр_ПреобразовательXSL")<>Неопределено тогда     
		//	ВнешняяКоманда = ПолучитьИсполняемыйФайлИзМакетаПутей("пр_ПреобразовательXSL",,);
		//ИначеЕсли Метаданные.ОбщиеМакеты.Найти("угсПреобразовательXSL")<>Неопределено Тогда
		//	ВнешняяКоманда = ПолучитьИсполняемыйФайлИзМакетаПутей("угсПреобразовательXSL",,);
		//КонецЕсли;
	КонецЕсли;
	

	// 1 сначала уберем namespace, чтобы работал for-each
	СтрокаПреобразования = "<?xml version = '1.0' encoding='UTF-8' ?>
	|<xsl:stylesheet version='1.0'
	|  xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>
	|	<xsl:output method='xml' version='1.0' encoding='UTF-8' indent='yes'/>
	|	<xsl:template match='@*|node()[not(self::*)]'>
	|		<xsl:copy/>
	|	</xsl:template>
	|	<xsl:template match='*'>
	|		<xsl:element name='{local-name()}'>
	|			<xsl:apply-templates select='node()|@*'/>
	|		</xsl:element>
	|	</xsl:template>
	|</xsl:stylesheet>"; 
	
	
	// вариант с преобразованием XSL
	//Преобразование = новый ПреобразованиеXSL;
	//Преобразование.ЗагрузитьИзСтроки(СтрокаПреобразования); 
	
	ИмяНовФайла = ПолучитьИмяВременногоФайла("xml"); 

	ПреобразоватьXSL(СтрокаПреобразования,ИмяФайла,ИмяНовФайла,ВнешняяКоманда);
	
	//ЗаписьXML = новый ЗаписьXML(); 
	//ЗаписьXML.ОткрытьФайл(ИмяНовФайла); 
	//Преобразование.ПреобразоватьИзФайла(ИмяФайла,ЗаписьXML);
	//ЗаписьXML.Закрыть(); 
	
	
	СтрокаПреобразования1 = "<?xml version='1.0' encoding='UTF-8'?>
	|<xsl:stylesheet version='1.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>
	|<xsl:output method='xml' version='1.0' encoding='UTF-8' indent='yes'/>
	|<xsl:template match='/'>
	|<xsl:element name='rows'>
	|<xsl:for-each select='"+ПутьXPATH_ДляПолученияСтрок+"'>
	|<xsl:element name='row'>"; 
	
	СтрокаПреобразования2 = "
	//|<xsl:element name='ИмяКолонки'><xsl:value-of select='ЗначениеКолонки' disable-output-escaping='yes'/></xsl:element>"; 
	|<xsl:element name='ИмяКолонки'><xsl:value-of select='ЗначениеКолонки' disable-output-escaping='no'/></xsl:element>"; 
	//|<xsl:text name='ИмяКолонки'><xsl:value-of select='ЗначениеКолонки' disable-output-escaping='yes'/></xsl:text>"; 
	
	НовПутиКолонок = новый СписокЗначений;
	СтрокаПреобразованияЦикл = "";
	Для каждого Эл Из ПутиXPATH_ДляПолученияКолонок Цикл
		Если ТипЗнч(ПутиXPATH_ДляПолученияКолонок)=Тип("Соответствие") тогда 
			ПутьКол  = Эл.Ключ;
			ИмяКол   = Эл.Значение;
		Иначе
			ПутьКол  = Эл.Значение;
			ИмяКол   = Эл.Представление;
		КонецЕсли; 	
		СтрДоб = СтрокаПреобразования2;
		СтрДоб = СтрЗаменить(СтрДоб,"ИмяКолонки",ИмяКол);
		СтрДоб = СтрЗаменить(СтрДоб,"ЗначениеКолонки",ПутьКол);
		СтрокаПреобразованияЦикл=СтрокаПреобразованияЦикл+СтрДоб;
		
		НовПутиКолонок.Добавить(ИмяКол,ИмяКол); 
	КонецЦикла; 

	СтрокаПреобразования3 = "
	|</xsl:element>
	|</xsl:for-each>
	|</xsl:element>
	|</xsl:template>
	|</xsl:stylesheet>"; 

	СтрокаПреобразования = СтрокаПреобразования1+СтрокаПреобразованияЦикл+СтрокаПреобразования3;

	ИмяНовФайла2 = ПолучитьИмяВременногоФайла("xml"); 
	
	//Преобразование.ЗагрузитьИзСтроки(СтрокаПреобразования); 
	//ЗаписьXML = новый ЗаписьXML(); 
	//ЗаписьXML.ОткрытьФайл(ИмяНовФайла2); 
	//Преобразование.ПреобразоватьИзФайла(ИмяНовФайла,ЗаписьXML);
	//ЗаписьXML.Закрыть(); 
	
	ПреобразоватьXSL(СтрокаПреобразования,ИмяНовФайла,ИмяНовФайла2,ВнешняяКоманда);
	
	НовПутьДляСтрок = "row";
	мНовПутьДляСтрок = новый Массив;
	мНовПутьДляСтрок.Добавить(НовПутьДляСтрок); 
	
	Рез = ПрочитатьДанныеИзXML(МассивКолонок,ИмяНовФайла2, мНовПутьДляСтрок, НовПутиКолонок,ДопДанные); 
	
	УдалитьФайлы(ИмяНовФайла); 
	УдалитьФайлы(ИмяНовФайла2); 
	
	Если Не Рез тогда 
		возврат  Ложь;
	КонецЕсли; 
	Рез = ПрочитатьТаблицуЗначенийИзМассива(ТЗ,МассивКолонок,1,2,Поля,Типы,ДопДанные); 
	возврат  Рез;
	
	
КонецФункции  

Функция ПреобразоватьXSL(СтрокаПреобразования,ИмяФайлаИсточник,ИмяФайлаПриемник,ВнешняяКоманда="")
	ИспользоватьВнешнееПреобразованиеXSL = Булево(ВнешняяКоманда = "DOM"); 
	Если ИспользоватьВнешнееПреобразованиеXSL Тогда                        
		ИмяФайлаСтилей = ПолучитьИмяВременногоФайла("xsl"); 

		Текст = Новый ЗаписьТекста(ИмяФайлаСтилей, КодировкаТекста.UTF8);
		Текст.Записать(СтрокаПреобразования);
		Текст.Закрыть();		

		ret=1;
    xmlDoc = DOM_НовыйXMLДокумент();
    xslDoc = DOM_НовыйXMLДокумент();
		Если xmlDoc<>Неопределено И xslDoc<>Неопределено Тогда
	    outDoc = Новый COMОбъект("ADODB.Stream");
	    outDoc.type = 1; //adTypeBinary;
	    outDoc.open();

	    Если xmlDoc.load(ИмяФайлаИсточник) = true тогда
	        Если xslDoc.load(ИмяФайлаСтилей) = true тогда 
		        xmlDoc.transformNodeToObject(xslDoc, outDoc);
		        outDoc.SaveToFile(ИмяФайлаПриемник, 2); //adSaveCreateOverWrite
						ret=0;
	        КонецЕсли;
	    КонецЕсли;
		КонецЕсли;
		
		//WshShell=Новый COMОбъект("wscript.shell");
		////msxsl.exe source stylesheet -o outfile
		//ret = WshShell.Run(""""+ВнешняяКоманда+""" """+ИмяФайлаИсточник+"""  """+ИмяФайлаСтилей+""" -o """+ИмяФайлаПриемник+"""",7,-1); 
		
		УдалитьФайлы(ИмяФайлаСтилей); 
		
		Если ret=0 Тогда
			возврат  истина;
	  иначе
			// возврат  ложь;                                                           
			// Если не удалось конвертировать внешней программой - запустим встроенную
			возврат ПреобразоватьXSL(СтрокаПреобразования,ИмяФайлаИсточник,ИмяФайлаПриемник);
	  КонецЕсли; 
			
	Иначе
		
		// вариант с преобразованием XSL
		Преобразование = новый ПреобразованиеXSL;
		Преобразование.ЗагрузитьИзСтроки(СтрокаПреобразования); 
		
		ЗаписьXML = новый ЗаписьXML(); 
		ЗаписьXML.ОткрытьФайл(ИмяФайлаПриемник); 
		Преобразование.ПреобразоватьИзФайла(ИмяФайлаИсточник,ЗаписьXML);
		ЗаписьXML.Закрыть(); 
		
		возврат  Истина;
	КонецЕсли;
	
КонецФункции                                          

Функция DOM_НовыйXMLДокумент() Экспорт
	XML = Неопределено ;
	Если XML = Неопределено Тогда
		Попытка
			XML = Новый COMОбъект("Msxml2.DOMDocument.6.0");
		Исключение
		КонецПопытки;
	КонецЕсли;
	Если XML = Неопределено Тогда
		Попытка
			XML = Новый COMОбъект("Msxml2.DOMDocument.4.0");
		Исключение
		КонецПопытки;
	КонецЕсли;
	Если XML = Неопределено Тогда
		Попытка
			XML = Новый COMОбъект("Msxml2.DOMDocument.3.0");
		Исключение
		КонецПопытки;
	КонецЕсли;
	Возврат XML;
КонецФункции

#КонецЕсли 

#КонецОбласти 


#Область ОбщиеФункции
//!!!!///// Общие функции ////////////////////////////////


// Если ПутьИлиАдресВХранилище - это адрес в хранилище, то в структуре ДопДанные должнен быть ключ ИмяФайла - для определения расширения 
// возвращает Истина - если ИмяФайла удалось заполнить
Функция ПроверитьИмяФайла(ПутьИлиАдресВХранилище,ДопДанные, ИмяФайла) 
	
	Если ДопДанные=Неопределено  Тогда
		ДопДанные=Новый Структура(); 
	КонецЕсли; 

	ЭтоСтрока = СвойствоСтруктуры(ДопДанные,"ЭтоСтрока",Ложь);
	Если ЭтоСтрока=Истина тогда 
  	Возврат Истина;
	КонецЕсли;
				
	ЭтоАдрес = ЭтоАдресВременногоХранилища(ПутьИлиАдресВХранилище); 
	ДопДанные.Вставить("ЭтоАдрес",ЭтоАдрес); 
	
	Если ЭтоАдрес Тогда
		#Если ВебКлиент Тогда
			Сообщение = Новый СообщениеПользователю;
			Сообщение.Текст = НСтр("ru = 'В web-клиенте с такими параметрами функция вызвана быть не может'");
			Сообщение.Сообщить(); 
			Возврат Ложь;
		#Иначе
			ДопДанныеИмяФайла = Неопределено;
			ДопДанные.Свойство("ИмяФайла",ДопДанныеИмяФайла); 
			Если ЗначениеЗаполнено(ДопДанныеИмяФайла)  Тогда
				Расширение = ПолучитьРасширениеИмениФайла(ДопДанныеИмяФайла); 	
			Иначе
				Расширение = "xls"; 
			КонецЕсли; 
			
			ДвоичныеДанные = ПолучитьИзВременногоХранилища (ПутьИлиАдресВХранилище);
			ИмяФайла = ПолучитьИмяВременногоФайла(Расширение);
			ДвоичныеДанные.Записать(ИмяФайла);
		#КонецЕсли 
	Иначе	
		ИмяФайла = ПутьИлиАдресВХранилище;
	КонецЕсли; 
	
	#Если НЕ Клиент Тогда
	Если БезопасныйРежим()=Ложь тогда 
	ВыбФайл = Новый Файл(ИмяФайла);
	Если НЕ ВыбФайл.Существует() Тогда
		Сообщение = Новый СообщениеПользователю; Сообщение.Текст = НСтр("ru = 'Файл не существует!'"); Сообщение.Сообщить(); 
		Возврат Ложь;
	КонецЕсли;
	КонецЕсли; 
	#КонецЕсли 
	
	Возврат Истина;
	
КонецФункции


//КАО_220415 если в строке есть несколько разделителей - остается последний
// пытается получить число из строки
Функция ЧислоИзСтроки(Знач Пар, Знач Длина=15, Знач Точность=5, Знач Знак="Любой")  Экспорт 
	Пар = СтрЗаменить(Пар,Символ(160),""); 
	Пар = СтрЗаменить(Пар," ","");       
	
	ПозицияЗапятой = Найти(Пар,",");
	ПозицияТочки = Найти(Пар,".");
	Если ПозицияЗапятой > 0 И ПозицияТочки > 0 Тогда
		Если ПозицияЗапятой>ПозицияТочки тогда 
			Пар = СтрЗаменить(Пар,".","");
		Иначе
			Пар = СтрЗаменить(Пар,",","");
		КонецЕсли; 	
	КонецЕсли; 
	
	ОписаниеТипаЧисло = новый ОписаниеТипов("Число",Новый КвалификаторыЧисла(Длина, Точность, ДопустимыйЗнак[Знак]));
	возврат ОписаниеТипаЧисло.ПривестиЗначение( Пар ) ;
КонецФункции 

Функция ДатаИзСтрокиСредствами1С(Знач ФорматДаты, Знач Дано, Ошибка = Ложь) Экспорт 
	//КАО_160101 версия 1.0
	//КАО_200814 Изменено определение в случае ДФ
	//КАО_240110 убираются лишние кавычки
	
	Если Лев(ФорматДаты,3)="ДФ=" или Лев(ФорматДаты,4)="ДФ =" тогда
		ФорматДаты = нстр(ФорматДаты,"ДФ"); 
	КонецЕсли; 	
	
	Попытка 
		ё = Формат('00010101', "ДФ=" + ФорматДаты) // - необязательная проверка первого правильности параметра 
	Исключение 
		Ошибка = Истина; 
		Возврат '00010101' 
	КонецПопытки; 
	
	ОписаниеТипаЧисло = новый ОписаниеТипов("Число",Новый КвалификаторыЧисла(4,0,ДопустимыйЗнак.Неотрицательный));
	
	ФорматДаты = СтрЗаменить(ФорматДаты,"'",""); //КАО_240110 Уберем одиночные кавычки
	ФорматДаты = СтрЗаменить(ФорматДаты,"""",""); //КАО_240110 Уберем двойные кавычки
	ФорматДаты = СтрЗаменить(ФорматДаты,"d","д"); 
	ФорматДаты = СтрЗаменить(ФорматДаты,"M","М"); 
	ФорматДаты = СтрЗаменить(ФорматДаты,"y","г"); 
	ФорматДаты = СтрЗаменить(ФорматДаты,"H","Ч"); 
	ФорматДаты = СтрЗаменить(ФорматДаты,"h","ч"); 
	ФорматДаты = СтрЗаменить(ФорматДаты,"m","м"); 
	ФорматДаты = СтрЗаменить(ФорматДаты,"s","с"); 
	
	ЧГод = Год(ТекущаяДата());
	ЧМесяц = 1;
	ЧДень = 1;
	ЧЧас = 0;
	ЧМинута = 0;
	ЧСекунда = 0;
	
	// строками могут только месяцы
	Если Найти(ФорматДаты, "ММММ") тогда // месяц с большой буквы
		Для ё = 1 По 12 Цикл 
			ПредставлениеМесяца = Формат(Дата(1, ё, 1), "ДФ=MMММ"); 
			Если Найти(Дано, ПредставлениеМесяца)>0 тогда
				Дано = СтрЗаменить(Дано, ПредставлениеМесяца, Формат(ё, "ЧЦ=2; ЧВН=")); // - замена названий месяцев числами 
				ФорматДаты = СтрЗаменить(ФорматДаты,"ММММ","ММ"); 
			КонецЕсли; 	
		КонецЦикла; 
	КонецЕсли; 
	Если Найти(ФорматДаты, "МММ") тогда // месяц с маленькой буквы
		Для ё = 1 По 12 Цикл 
			ПредставлениеМесяца = Формат(Дата(1, ё, 1), "ДФ=MMМ"); 
			Если Найти(Дано, ПредставлениеМесяца)>0 тогда
				Дано = СтрЗаменить(Дано, ПредставлениеМесяца, Формат(ё, "ЧЦ=2; ЧВН=")); // - замена названий месяцев числами 
				ФорматДаты = СтрЗаменить(ФорматДаты,"МММ","ММ"); 
			КонецЕсли; 	
		КонецЦикла; 
	КонецЕсли; 
	
	СтрокаФормСимволов = "дМгЧчмс"; 
	Пока Истина Цикл
		Если СтрДлина(ФорматДаты)<=0 тогда
			Прервать;
		КонецЕсли; 	
		ПервСимв = Лев(ФорматДаты,1); 
		Если Найти(СтрокаФормСимволов,ПервСимв)=0 тогда // обычный символ - пропустим
			ФорматДаты = Сред(ФорматДаты,2); 
			Дано = Сред(Дано,2); 
			Продолжить;
		КонецЕсли; 	
		
		// это форматная строка 
		Если лев(ФорматДаты,4)="гггг" тогда // это год 4 символа
			ЧГод = ОписаниеТипаЧисло.ПривестиЗначение(Лев(Дано,4)); 
			ФорматДаты = Сред(ФорматДаты,5); 
			Дано = Сред(Дано,5); 
			Продолжить;
		КонецЕсли; 	
		Если лев(ФорматДаты,3)="ггг" тогда // это год 3 символа
			ЧГод = ОписаниеТипаЧисло.ПривестиЗначение(Лев(Дано,4)); 
			ФорматДаты = Сред(ФорматДаты,4); 
			Дано = Сред(Дано,5); 
			Продолжить;
		КонецЕсли; 	
		
		// короткие представления
		Если лев(ФорматДаты,1)="г" тогда // это год 1-2 символа 
			Если лев(ФорматДаты,2)="гг" тогда
				СдвигФормата = 3;
			Иначе
				СдвигФормата = 2;
			КонецЕсли; 	
			ФорматДаты = Сред(ФорматДаты,СдвигФормата); 
			ЧГод = ОписаниеТипаЧисло.ПривестиЗначение("20"+Лев(Дано,2)); 
			Дано = Сред(Дано,3); 
			Продолжить;
		КонецЕсли; 	
		Если лев(ФорматДаты,1)="М" тогда // это месяц 1-2 символа
			Если лев(ФорматДаты,2)="ММ" тогда
				СдвигФормата = 3;
			Иначе
				СдвигФормата = 2;
			КонецЕсли; 	
			ФорматДаты = Сред(ФорматДаты,СдвигФормата); 
			
			СМесяц = Лев(Дано,1); 
			Дано = Сред(Дано,2); 
			Если СМесяц = "0" ИЛИ СМесяц = "1" тогда // может быть 2-я цифра 
				СМесяц2 = Лев(Дано,1); 
				Если ЭтоЦифра(СМесяц2) тогда // может быть 2-я цифра 
					СМесяц = СМесяц+СМесяц2;
					Дано = Сред(Дано,2); 
				КонецЕсли; 	
			КонецЕсли; 
			ЧМесяц =ОписаниеТипаЧисло.ПривестиЗначение(СМесяц); 
			Продолжить;
		КонецЕсли; 	
		
		Если лев(ФорматДаты,1)="д" тогда // это день 1-2 символа
			Если лев(ФорматДаты,2)="дд" тогда
				СдвигФормата = 3;
			Иначе
				СдвигФормата = 2;
			КонецЕсли; 	
			ФорматДаты = Сред(ФорматДаты,СдвигФормата); 
			
			СДень = Лев(Дано,1); 
			Дано = Сред(Дано,2); 
			Если СДень = "0" или СДень = "1" или СДень = "2" или СДень = "3" тогда // может быть 2-я цифра 
				СДень2 = Лев(Дано,1); 
				Если ЭтоЦифра(СДень2)  тогда // может быть 2-я цифра 
					СДень = СДень+СДень2;
					Дано = Сред(Дано,2); 
				КонецЕсли; 	
			КонецЕсли; 
			ЧДень =ОписаниеТипаЧисло.ПривестиЗначение(СДень); 
			Продолжить;
		КонецЕсли; 	
		
		Если лев(ФорматДаты,1)="ч" или лев(ФорматДаты,1)="Ч" тогда // это час 1-2 символа
			Если лев(ФорматДаты,2)="чч" или лев(ФорматДаты,2)="ЧЧ" тогда
				СдвигФормата = 3;
			Иначе
				СдвигФормата = 2;
			КонецЕсли; 	
			Если лев(ФорматДаты,1)="ч" тогда // короткий формат времени
				ДобЧас = 0; // не добавляем, не понятно 1 - это час или тринадцать
			Иначе
				ДобЧас = 0;
			КонецЕсли; 	
			ФорматДаты = Сред(ФорматДаты,СдвигФормата); 
			
			СЧас = Лев(Дано,1); 
			Дано = Сред(Дано,2); 
			Если СЧас = "0" или СЧас = "1" или СЧас = "2" тогда // может быть 2-я цифра 
				СЧас2 = Лев(Дано,1); 
				Если ЭтоЦифра(СЧас2) тогда // может быть 2-я цифра 
					СЧас = СЧас+СЧас2;
					Дано = Сред(Дано,2); 
				КонецЕсли; 	
			КонецЕсли; 
			ЧЧас = ОписаниеТипаЧисло.ПривестиЗначение(СЧас)+ДобЧас; 
			Продолжить;
		КонецЕсли; 	
		
		Если лев(ФорматДаты,1)="м" тогда // это минута 1-2 символа
			Если лев(ФорматДаты,2)="мм" тогда
				СдвигФормата = 3;
			Иначе
				СдвигФормата = 2;
			КонецЕсли; 	
			ФорматДаты = Сред(ФорматДаты,СдвигФормата); 
			
			СМинута = Лев(Дано,1); 
			Дано = Сред(Дано,2); 
			Если СМинута = "0" или СМинута = "1" или СМинута = "2" или СМинута = "3"  или СМинута = "4" или СМинута = "5" тогда // может быть 2-я цифра 
				СМинута2 = Лев(Дано,1); 
				Если ЭтоЦифра(СМинута2)  тогда // может быть 2-я цифра 
					СМинута = СМинута+СМинута2;
					Дано = Сред(Дано,2); 
				КонецЕсли; 	
			КонецЕсли; 
			ЧМинута =ОписаниеТипаЧисло.ПривестиЗначение(СМинута); 
			Продолжить;
		КонецЕсли; 	
		
		Если лев(ФорматДаты,1)="с" тогда // это секунда 1-2 символа
			Если лев(ФорматДаты,2)="сс" тогда
				СдвигФормата = 3;
			Иначе
				СдвигФормата = 2;
			КонецЕсли; 	
			ФорматДаты = Сред(ФорматДаты,СдвигФормата); 
			
			ССекунда = Лев(Дано,1); 
			Дано = Сред(Дано,2); 
			Если ССекунда = "0" или ССекунда = "1" или ССекунда = "2" или ССекунда = "3"  или ССекунда = "4" или ССекунда = "5" тогда // может быть 2-я цифра 
				ССекунда2 = Лев(Дано,1); 
				Если ЭтоЦифра(ССекунда2)  тогда // может быть 2-я цифра 
					ССекунда = ССекунда+ССекунда2;
					Дано = Сред(Дано,2); 
				КонецЕсли; 	
			КонецЕсли; 
			ЧСекунда =ОписаниеТипаЧисло.ПривестиЗначение(ССекунда); 
			Продолжить;
		КонецЕсли; 	
		
	КонецЦикла; 
	
	Попытка 
		Возврат Дата(ЧГод, ЧМесяц, ЧДень, ЧЧас, ЧМинута, ЧСекунда) ; 
	Исключение 
		Ошибка = Истина; 
		Возврат '00010101' 
	КонецПопытки 
КонецФункции 


// Возвращает дату из строки Пар, описанную в определенном формате Фрмт
// Если ПроверятьЧислоДнейExcel=Истина - сначала проверяет, что запись количесва дней от 01.01.1900
//   которую создает Excel в случае, если не указан формат даты.
// В ПоискУспешен возвращается флаг, указавающий на результат поиска
// Формат: форматная строка 1С, в случае пустого значения - пытается разобрать автоматически
Функция ДатаИзСтроки(знач Пар,знач Фрмт="",ПоискУспешен=ложь, ПроверятьЧислоДнейExcel=Истина)  Экспорт 
	//КАО_200814 Если год<100 - добавляем 2000
	
	Если Не ЗначениеЗаполнено(Пар)  тогда // пустое значение
		ПоискУспешен = Истина; 
		возврат '00010101';
	КонецЕсли ;		

	Если ТипЗнч(Пар) = Тип("Дата") тогда // это уже дата
		ПоискУспешен = Истина; 
		возврат Пар;
	КонецЕсли ;		

	ПарС = СокрЛП(Пар);
	Если ПарС=". ." или ПарС=".  ."  или ПарС=".." или ПарС="/ /" или ПарС="/  /" или ПарС="//" тогда // пустое значение
		ПоискУспешен = Истина; 
		возврат '00010101';
	КонецЕсли ;		
	
	Если ТипЗнч(Пар) = Тип("Число") тогда // значение представлено в виде числа, тогда это число дней от 01.01.1900 (Excel)
		Если ПроверятьЧислоДнейExcel тогда	
			ПарД = Пар ; 
			Если ПарД>0 тогда // значение представлено в виде числа, тогда это число дней от 01.01.1900 (Excel)
				Дрет = '19000101' + (ПарД-1)*60*60*24 - 1 ; 
				ПоискУспешен = Истина; 
				возврат Дрет;
			Иначе	
				ПоискУспешен = Ложь; 
				возврат '00010101';
			КонецЕсли ;     
		Иначе
			ПоискУспешен = Ложь; 
			возврат '00010101';
		КонецЕсли; 	
	КонецЕсли; 
	
	Если ТипЗнч(Фрмт)=Тип("Массив") Тогда
		Для каждого эФрмт Из Фрмт Цикл
			Дрет = ДатаИзСтроки(Пар,эФрмт,ПоискУспешен, ПроверятьЧислоДнейExcel) ; 
			Если ПоискУспешен тогда
				возврат  Дрет;
			КонецЕсли; 	
		КонецЦикла; 
		возврат  '00010101'; 
	КонецЕсли; 
	
	Если ЗначениеЗаполнено(Фрмт) тогда // есть формат
		Ошибка = Ложь;
		Дрет = ДатаИзСтрокиСредствами1С(Фрмт, ПарС, Ошибка) ; 
		ПоискУспешен = НЕ Ошибка;
		Если ПоискУспешен И Дрет<>'00010101' И Дрет<'01000101' тогда  
			Дрет=ДобавитьМесяц(Дрет,2000*12); 
		КонецЕсли; 	
		возврат  Дрет;
	КонецЕсли; 	

	возврат '00010101';
КонецФункции	


// Функция - Заполнить массив
//
// Параметры:
//  Массив	 -  массив	 - подготовленный массив
//  Значение - 	 - Заполняемое значение
// 
Функция ЗаполнитьМассив(Массив, Значение) экспорт
	Н=0;
	Для Н=0 по Массив.ВГраница() Цикл
		Массив[Н]=Значение;
	КонецЦикла; 
КонецФункции

// Функция - Создать заполненный массив
//
// Параметры:
//  Длина		 - число	 - длина массива
//  Значение - 	 -  значение, которым заполняется массив
// 
// Возвращаемое значение:
//  массив - созданный массив
//
Функция СоздатьЗаполненныйМассив(Длина,Значение) экспорт
	Мас = новый Массив(Длина); 
	ЗаполнитьМассив(Мас,Значение);
	возврат  Мас;
КонецФункции


Функция СвойствоСтруктуры(Структура, Свойство, ЗначениеПоУмолчанию=Неопределено) Экспорт
//Назначение: Возвращает свойство структуры, а если его нет, то переданный параметр по умолчанию
//ДатаСоздания: 20070531
//Автор: Fixin
//СтароеИмя: СтруктураСвойство
//Тестирована: Да
	Перем Значение;
	Если ТипЗнч(Структура)<>Тип("Структура") Тогда
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;
	Если Структура.Свойство(Свойство, Значение) Тогда
		Возврат Значение;
	КонецЕсли;
	Возврат ЗначениеПоУмолчанию;
КонецФункции

//КАО_121224  копирует структуру 
// если ИсхСтруктура не является структурой возвращает пустую структуру
Функция СкопироватьСтруктуру(ИсхСтруктура) экспорт
	НовСтруктура = Новый Структура;
	Если ТипЗнч(ИсхСтруктура)=Тип("Структура") Тогда
		Для Каждого Эл Из ИсхСтруктура Цикл
		 НовСтруктура.Вставить( Эл.Ключ , Эл.Значение );
	 	КонецЦикла;	
	КонецЕсли; 
	возврат  НовСтруктура;
КонецФункции

Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Тип("Строка"));
	
	КвалификаторСтроки = Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная);
	
	Возврат Новый ОписаниеТипов(Массив, , КвалификаторСтроки);
	
КонецФункции // ПолучитьОписаниеТиповСтроки()

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
//
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//  ЗнакЧисла				- ДопустимыйЗнак, знак числа
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность, РазрядностьДробнойЧасти = 0, ЗнакЧисла = Неопределено) Экспорт
	
	Если ЗнакЧисла = Неопределено Тогда
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти);
	Иначе
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, ЗнакЧисла);
	КонецЕсли;
	
	Возврат Новый ОписаниеТипов("Число", КвалификаторЧисла);
	
КонецФункции // ПолучитьОписаниеТиповЧисла()

// Служебная функция, предназначенная для получения описания типов даты
//
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
//
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Тип("Дата"));
	
	КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты);
	
	Возврат Новый ОписаниеТипов(Массив, , , КвалификаторДаты);
	
КонецФункции // ПолучитьОписаниеТиповДаты()

//Выполняет в строке ГДЕ замену символов ЧТО на соответствующие по номерам символы из строки НаЧто
Функция ЗаменитьОдниСимволыДругими(Что,Где,НаЧто) Экспорт
	Рез = Где;
	Для Сч=1 По СтрДлина(Что) Цикл
		Рез = СтрЗаменить(Рез,Сред(Что,Сч,1),Сред(НаЧто,Сч,1));
	КонецЦикла;
	Возврат Рез;
КонецФункции

// удаляет неиспользуемые символы из имени фаыла
Функция ОчиститьИмяФайла(ИмяФайла) экспорт
	Возврат ЗаменитьОдниСимволыДругими(" \/:;^&",ИмяФайла,"_______")
КонецФункции	


Функция ЭтоСимволИдентификатора(С) Экспорт
	Возврат С="_" ИЛИ ЭтоБуква(С) ИЛИ ЭтоЦифра(С) ;
КонецФункции

//Из библиотеки функций для продвинутой работы в 1С 80 - fixin
//Проверяет, является ли символ цифрой
Функция ЭтоЦифра(С) Экспорт
	Возврат Найти("0123456789", С)<>0;
КонецФункции

//Проверяет, является ли символ буквой
Функция ЭтоБуква(С) Экспорт
	Возврат ЭтоРусскаяБуква(С) ИЛИ ЭтоЛатинскаяБуква(С);
КонецФункции

Функция ЭтоРусскаяБуква(С) Экспорт
	Возврат Найти("АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЫЬЪЭЮЯ", ВРег(С))<>0;
КонецФункции

Функция ЭтоЛатинскаяБуква(С) Экспорт
	Возврат Найти("ABCDEFGHIJKLMNOPQRSTUVWXYZ", ВРег(С))<>0;
КонецФункции

Функция УдалитьНеиспользуемыеСимволы(Знач Имя)  Экспорт 

	Имя = СокрЛП(Имя); 
	Рет = "";
	
	Для СЦ=1 по СтрДлина(Имя) цикл
		ТекСимвол = Сред(Имя,СЦ,1); 
		Если ТекСимвол="№" тогда
			НовСимвол = "N" ; 
		//КАО_220802 Упрощаем создание идентификатора - заносим только символы идентификатора	
		//ИначеЕсли Найти(" +-:;",ТекСимвол)>0 тогда
		//	НовСимвол = "_" ; 
		ИначеЕсли ЭтоСимволИдентификатора(ТекСимвол) тогда
			НовСимвол = ТекСимвол ; 
		//ИначеЕсли ЭтоБуква(ТекСимвол) ИЛИ ЭтоЦифра(ТекСимвол)	тогда 		
		//	НовСимвол = ТекСимвол ; 
		Иначе  
			НовСимвол = ""; 
		КонецЕсли ;      
		Рет = Рет + НовСимвол ;  
	КонецЦикла;
	
	НачСимвол = Лев(Рет,1); 
	Если НачСимвол="" тогда 
		Рет = "_"; // пустое имя не подходит
	ИначеЕсли НачСимвол="_" ИЛИ ЭтоБуква(НачСимвол) тогда
	Иначе
		// так идентификатор начинаться не может - добавим префикс
		Рет = "_"+Рет; 
	КонецЕсли ;      

	возврат  Рет;
КонецФункции


// Заменить символы так, чтобы имя могло быть идентификтором
// если СтруктураСуществующихИдентификаторов - структура - проверяет, чтобы 
// идентификатор был уникальным и добавляет новое имя как ключ в структуру
Функция ПреобразоватьКИдентификатору(Знач Имя, СтруктураСуществующихИдентификаторов=Неопределено)  Экспорт 
	
	Рет = УдалитьНеиспользуемыеСимволы(Имя); 
	
	Если ТипЗнч(СтруктураСуществующихИдентификаторов) = Тип("Структура") тогда
		// надо обеспечить, чтобы идентификаторы были уникальны
		РетПр = Рет ; 
		СЦ = 1 ; 
		Пока СтруктураСуществующихИдентификаторов.Свойство(Рет) цикл
			Рет = РетПр + ""+Формат(СЦ,"ЧГ=0") ; 
			СЦ = СЦ+1 ; 
		КонецЦикла;   
		СтруктураСуществующихИдентификаторов.Вставить(Рет,Истина); 
	КонецЕсли ;      
	
	Возврат рет ; 
КонецФункции               

//КАО_150217 ОписаниеКолонок - Структура с описаниеми колонок ТЗ
Функция ДобавитьОписаниеКолонкиТЗ(ОписаниеКолонок, Имя, Тип=Неопределено, Заголовок=Неопределено, Ширина=Неопределено) 
	ОписаниеКолонки=новый Структура("Имя,Тип,Заголовок,Ширина",Имя,Тип,Заголовок,Ширина);
	ОписаниеКолонок.вставить(Имя,ОписаниеКолонки); 
	возврат ОписаниеКолонок ;
КонецФункции

// Выделяет из имени файла его расширение (набор символов после последней точки).
//
// Параметры:
//  ИмяФайла – Строка, содержащая имя файла, неважно с именем каталога или без.
//
// Возвращаемое значение:
//   Строка – расширение файла.
//
Функция ПолучитьРасширениеИмениФайла(Знач ИмяФайла) Экспорт
	
	Расширение = "";
	
	ПозицияСимвола = СтрДлина(ИмяФайла);
	Пока ПозицияСимвола >= 1 Цикл
		
		Если Сред(ИмяФайла, ПозицияСимвола, 1) = "." Тогда
			
			Расширение = Сред(ИмяФайла, ПозицияСимвола + 1);
			Прервать;
		КонецЕсли;
		
		ПозицияСимвола = ПозицияСимвола - 1;
	КонецЦикла;

	Возврат Расширение;
	
КонецФункции


// Раскладывает полное имя файла на составляющие.
//
// Параметры:
//  ПолноеИмяФайла - Строка - полный путь к файлу.
//  ЭтоПапка - Булево - признак того, что требуется разложить полное имя папки, а не файла.
//
// Возвращаемое значение:
//   Структура - имя файла, разложенное на составные части(аналогично свойствам объекта Файл):
//		ПолноеИмя - Содержит полный путь к файлу, т.е. полностью соответствует входному параметру ПолноеИмяФайла.
//		Путь - Содержит путь к каталогу, в котором лежит файл.
//		Имя - Содержит имя файла с расширением, без пути к файлу.
//		Расширение - Содержит расширение файла.
//		ИмяБезРасширения - Содержит имя файла без расширения и без пути к файлу.
//			Пример: если ПолноеИмяФайла = "c:\temp\test.txt", то структура заполнится следующим образом:
//				ПолноеИмя: "c:\temp\test.txt".
//				Путь: "c:\temp\"
//				Имя: "test.txt"
//				Расширение: ".txt"
//				ИмяБезРасширения: "test".
//
Функция РазложитьПолноеИмяФайла(Знач ПолноеИмяФайла, ЭтоПапка = Ложь) Экспорт
	
	СтруктураИмениФайла = Новый Структура("ПолноеИмя,Путь,Имя,Расширение,ИмяБезРасширения");
	
	// Убираем из полного имени файла завершающий слеш и сохраняем получившееся полное имя в структуре
	Если ЭтоПапка И (Прав(ПолноеИмяФайла, 1) = "/" Или Прав(ПолноеИмяФайла, 1) = "\") Тогда
		Если ЭтоПапка Тогда
			ПолноеИмяФайла = Сред(ПолноеИмяФайла, 1, СтрДлина(ПолноеИмяФайла) - 1);
		Иначе
			// Если путь к файлу заканчивается слешем, то у файла нет имени.
			СтруктураИмениФайла.Вставить("ПолноеИмя", ПолноеИмяФайла); 
			СтруктураИмениФайла.Вставить("Путь", ПолноеИмяФайла); 
			СтруктураИмениФайла.Вставить("Имя", ""); 
			СтруктураИмениФайла.Вставить("Расширение", ""); 
			СтруктураИмениФайла.Вставить("ИмяБезРасширения", ""); 
			Возврат СтруктураИмениФайла;
		КонецЕсли;
	КонецЕсли;
	СтруктураИмениФайла.Вставить("ПолноеИмя", ПолноеИмяФайла); 
	
	// Если полное имя файла оказалось пустым, то остальные параметры структуры возвращаем пустыми
	Если СтрДлина(ПолноеИмяФайла) = 0 Тогда 
		СтруктураИмениФайла.Вставить("Путь", ""); 
		СтруктураИмениФайла.Вставить("Имя", ""); 
		СтруктураИмениФайла.Вставить("Расширение", ""); 
		СтруктураИмениФайла.Вставить("ИмяБезРасширения", ""); 
		Возврат СтруктураИмениФайла;
	КонецЕсли;
	
	// Выделяем путь к файлу и имя файла
	Если Найти(ПолноеИмяФайла, "/") > 0 Тогда
		ПозицияРазделителя = НайтиСимволСКонца(ПолноеИмяФайла, "/");
	ИначеЕсли Найти(ПолноеИмяФайла, "\") > 0 Тогда
		ПозицияРазделителя = НайтиСимволСКонца(ПолноеИмяФайла, "\");
	Иначе
		ПозицияРазделителя = 0;
	КонецЕсли;
	СтруктураИмениФайла.Вставить("Путь", Лев(ПолноеИмяФайла, ПозицияРазделителя)); 
	СтруктураИмениФайла.Вставить("Имя", Сред(ПолноеИмяФайла, ПозицияРазделителя + 1));
	
	// Папки не имеют расширений, а для файла выделяем расширение
	Если ЭтоПапка Тогда
		СтруктураИмениФайла.Вставить("Расширение", "");
		СтруктураИмениФайла.Вставить("ИмяБезРасширения", СтруктураИмениФайла.Имя);
	Иначе
        ПозицияТочки = НайтиСимволСКонца(СтруктураИмениФайла.Имя, ".");
		Если ПозицияТочки = 0 Тогда
			СтруктураИмениФайла.Вставить("Расширение", "");
			СтруктураИмениФайла.Вставить("ИмяБезРасширения", СтруктураИмениФайла.Имя);
		Иначе
			СтруктураИмениФайла.Вставить("Расширение", Сред(СтруктураИмениФайла.Имя, ПозицияТочки));
			СтруктураИмениФайла.Вставить("ИмяБезРасширения", Лев(СтруктураИмениФайла.Имя, ПозицияТочки - 1));
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтруктураИмениФайла;
	
КонецФункции

// Осуществляет поиск символа, начиная с конца строки.
//
// Параметры:
//  Строка - Строка - строка, в которой осуществляется поиск;
//  Символ - Строка - искомый символ. Допускается искать строку, содержащую более одного символа.
//
// Возвращаемое значение:
//  Число - позиция символа в строке. 
//          Если строка не содержит указанного символа, то возвращается 0.
//
Функция НайтиСимволСКонца(Знач Строка, Знач Символ) Экспорт
	
	Для Позиция = -СтрДлина(Строка) По -1 Цикл
		Если Сред(Строка, -Позиция, СтрДлина(Символ)) = Символ Тогда
			Возврат -Позиция;
		КонецЕсли;
	КонецЦикла;
	
	Возврат 0;
		
КонецФункции

#КонецОбласти 

#Область ОбщиеСерверныеФункции

#Если НЕ ТонкийКлиент и НЕ ВебКлиент Тогда
	
//// Функции из модуля ДлительныеОперации БСП 2.3

// Регистрирует информацию о ходе выполнения фонового задания.
// В дальнейшем ее можно считать при помощи функции ПрочитатьПрогресс.
//
// Параметры:
//  Процент - Число  - Необязательный. Процент выполнения.
//  Текст   - Строка - Необязательный. Информация о текущей операции.
//  ДополнительныеПараметры - Произвольный - Необязательный. Любая дополнительная информация,
//      которую необходимо передать на клиент. Значение должно быть простым (сериализуемым в XML строку).
//
Процедура СообщитьПрогресс(Знач Процент = Неопределено, Знач Текст = Неопределено, Знач ДополнительныеПараметры = Неопределено) 
	
	Если ПолучитьТекущийСеансИнформационнойБазы().ПолучитьФоновоеЗадание() = Неопределено Тогда
		Возврат;
	КонецЕсли;
		
	ПередаваемоеЗначение = Новый Структура;
	Если Процент <> Неопределено Тогда
		ПередаваемоеЗначение.Вставить("Процент", Процент);
	КонецЕсли;
	Если Текст <> Неопределено Тогда
		ПередаваемоеЗначение.Вставить("Текст", Текст);
	КонецЕсли;
	Если ДополнительныеПараметры <> Неопределено Тогда
		ПередаваемоеЗначение.Вставить("ДополнительныеПараметры", ДополнительныеПараметры);
	КонецЕсли;
	
	ПередаваемыйТекст = ЗначениеВСтрокуXML(ПередаваемоеЗначение);
	
	Текст = "{" + СообщениеПрогресса() + "}" + ПередаваемыйТекст;
	Сообщение = Новый СообщениеПользователю;	Сообщение.Текст = Текст; Сообщение.Сообщить();
	
КонецПроцедуры

// Считывает информацию о ходе выполнения фонового задания.
//
// Параметры:
//   ИдентификаторЗадания - УникальныйИдентификатор - идентификатор фонового задания.
//
// Возвращаемое значение:
//   Неопределено, Структура - информация о ходе выполнения фонового задания, записанная процедурой СообщитьПрогресс:
//    * Процент                 - Число  - Необязательный. Процент выполнения.
//    * Текст                   - Строка - Необязательный. Информация о текущей операции.
//    * ДополнительныеПараметры - Произвольный - Необязательный. Любая дополнительная информация.
//
Функция ПрочитатьПрогресс(Знач ИдентификаторЗадания) Экспорт
	
	Возврат ПрочитатьПрогрессИСообщения(ИдентификаторЗадания, "Прогресс").Прогресс;
	
КонецФункции


// Считывает информацию о ходе выполнения фонового задания и сообщения, которые в нем были сформированы.
//
// Параметры:
//   ИдентификаторЗадания - УникальныйИдентификатор - идентификатор фонового задания.
//   Режим                - Строка - "ПрогрессИСообщения", "Прогресс" или "Сообщения".
//
// Возвращаемое значение:
//   Структура - со свойствами:
//    * Прогресс  - Неопределено, Структура - Информация о ходе выполнения фонового задания, записанная процедурой СообщитьПрогресс:
//     ** Процент                 - Число  - Необязательный. Процент выполнения.
//     ** Текст                   - Строка - Необязательный. Информация о текущей операции.
//     ** ДополнительныеПараметры - Произвольный - Необязательный. Любая дополнительная информация.
//    * Сообщения - ФиксированныйМассив - Массив объектов СообщениеПользователю, которые были сформированы в фоновом задании.
//
Функция ПрочитатьПрогрессИСообщения(Знач ИдентификаторЗадания, Знач Режим = "ПрогрессИСообщения")
	
	Результат = Новый Структура("Сообщения, Прогресс", Новый Массив, Неопределено);
	
	Задание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(ИдентификаторЗадания);
	Если Задание = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;
	
	МассивСообщений = Задание.ПолучитьСообщенияПользователю(Истина);
	Если МассивСообщений = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;
	
	Количество = МассивСообщений.Количество();
	Сообщения = Новый Массив;
	ЧитатьСообщения = (Режим = "ПрогрессИСообщения" Или Режим = "Сообщения"); 
	ЧитатьПрогресс  = (Режим = "ПрогрессИСообщения" Или Режим = "Прогресс"); 
	
	Если ЧитатьСообщения И Не ЧитатьПрогресс Тогда
		Результат.Сообщения = Новый ФиксированныйМассив(МассивСообщений);
		Возврат Результат;
	КонецЕсли;
	
	Для Номер = 0 По Количество - 1 Цикл
		Сообщение = МассивСообщений[Номер];
		
		Если ЧитатьПрогресс И Найти(Сообщение.Текст, "{")=1 Тогда
			Позиция = Найти(Сообщение.Текст, "}");
			Если Позиция > 2 Тогда
				ИдентификаторМеханизма = Сред(Сообщение.Текст, 2, Позиция - 2);
				Если ИдентификаторМеханизма = СообщениеПрогресса() Тогда
					ПолученныйТекст = Сред(Сообщение.Текст, Позиция + 1);
					Результат.Прогресс = ЗначениеИзСтрокиXML(ПолученныйТекст);
					Продолжить;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если ЧитатьСообщения Тогда
			Сообщения.Добавить(Сообщение);
		КонецЕсли;
	КонецЦикла;
	
	Результат.Сообщения = Новый ФиксированныйМассив(Сообщения);
	Возврат Результат;
	
КонецФункции

Функция СообщениеПрогресса()
	Возврат "СтандартныеПодсистемы.ДлительныеОперации";
КонецФункции

Функция НайтиЗаданиеПоИдентификатору(Знач ИдентификаторЗадания)
	
	Если ТипЗнч(ИдентификаторЗадания) = Тип("Строка") Тогда
		ИдентификаторЗадания = Новый УникальныйИдентификатор(ИдентификаторЗадания);
	КонецЕсли;
	
	Задание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(ИдентификаторЗадания);
	Возврат Задание;
	
КонецФункции

//// Функции из модуля ДлительныеОперации БСП 2.3
	
Функция ЭтоФоновоеЗадание()
	Если ПолучитьТекущийСеансИнформационнойБазы().ПолучитьФоновоеЗадание() = Неопределено Тогда
		Возврат Ложь;
	Иначе	
		Возврат Истина;
	КонецЕсли;
КонецФункции
	
	
// Возвращает значение в виде XML-строки.
// Преобразованы в XML-строку (сериализованы) могут быть только те объекты, 
// для которых в описании указано, что они сериализуются.
//
// Параметры:
//   Значение - Произвольный. Значение, которое необходимо сериализовать в XML-строку.
//
// Возвращаемое значение:
//   Строка - XML-строка представления значения в сериализованном виде.
//
Функция ЗначениеВСтрокуXML(Значение) 
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, Значение, НазначениеТипаXML.Явное);
	
	Возврат ЗаписьXML.Закрыть();
КонецФункции

// Возвращает значение, полученное из XML-строки. 
// Получены из XML-строки могут быть только те объекты, 
// для которых в описании указано, что они сериализуются.
//
// Параметры:
// СтрокаXML - строка представления значения в сериализованном виде.
//
// Возвращаемое значение:
// Значение, полученное из переданной XML-строки.
//
Функция ЗначениеИзСтрокиXML(СтрокаXML) 
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	
	Возврат СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
КонецФункции

// Возвращает массив Список в виде XML-строки в упрощенном формате (header,rows).
// Параметры:
//   Список - массив с объектами, выгружаемыми функцией Объект2XML:  
//   Данные - Структура с ключами: 
//				ИмяФайла - небязательный, если есть запись в файл, иначе в строку
// 				ИмяШапки - имя шапки, "header" 
//				ИмяОбъекта - имя объекта, "object" (если не заполнено в самом объекте)
//				ЗаписыватьОбъявлениеXML - булево - если ключа нет - истина
//                  
// Возвращаемое значение:
//   Строка - XML-строка представления данных в упрощенном формате (header,rows) 
Функция Список2XML(Список, Данные) экспорт
	ИмяФайла = СвойствоСтруктуры(Данные,"ИмяФайла",Неопределено); 
	ИмяШапки = СвойствоСтруктуры(Данные,"ИмяШапки","header"); 
	ИмяОбъекта = СвойствоСтруктуры(Данные,"ИмяОбъекта","object"); 
	ЗаписыватьОбъявлениеXML = СвойствоСтруктуры(Данные,"ЗаписыватьОбъявлениеXML",Истина); 
	
	ПарамЗаписи = Новый ПараметрыЗаписиXML("UTF-8","1.0"); 
	ЗаписьXML = Новый ЗаписьXML();
	//ЗаписьXML.Параметры = ПарамЗаписи;
	Если не ЗначениеЗаполнено(ИмяФайла)  Тогда
		ЗаписьXML.УстановитьСтроку();
	Иначе	
		ЗаписьXML.ОткрытьФайл(ИмяФайла,ПарамЗаписи);
	КонецЕсли; 
	
	Если ЗаписыватьОбъявлениеXML Тогда
		ЗаписьXML.ЗаписатьОбъявлениеXML();
	КонецЕсли; 
	
	ЗаписьXML.ЗаписатьНачалоЭлемента(ИмяШапки);
	
	Для каждого Объект Из Список Цикл
		ИмяШапкиОбъекта = СвойствоСтруктуры(Объект,"ИмяШапки",Неопределено); 	
		Если не ЗначениеЗаполнено( ИмяШапкиОбъекта ) тогда 
			Объект.Вставить("ИмяШапки",ИмяОбъекта);
			Объект2XML(Объект, ЗаписьXML); 
		КонецЕсли; 	
	КонецЦикла; 
	
	ЗаписьXML.ЗаписатьКонецЭлемента();
	
	XMLСтрока = ЗаписьXML.Закрыть();
	Возврат XMLСтрока;
КонецФункции

// Возвращает структуру Данные в виде XML-строки в упрощенном формате (header,rows).
// Параметры:
//   Данные - Структура с ключами: 
//				ИмяФайла - небязательный, если есть запись в файл, иначе в строку
//				Шапка, ИмяШапки, ТЧ1, ТЧ2, ТЧ3, ИмяТЧ1, ИмяТЧ2, ИмяТЧ3, ИмяСтрок1, ИмяСтрок2, ИмяСтрок3
//				ЗаписыватьОбъявлениеXML - булево - если ключа нет - истина, используется только если ЗаписьXML=Неопределено
//   Если ЗаписьXML=Неопределено - делает выгрузку одного объекта, иначе может использоваться для списка 
//                  
// Возвращаемое значение:
//   Строка, Булево - XML-строка представления данных в упрощенном формате (header,rows) ИЛИ истина если ЗаписьXML была передана параметром
Функция Объект2XML(Данные, ЗаписьXML=Неопределено) экспорт
	ИмяФайла = СвойствоСтруктуры(Данные,"ИмяФайла",Неопределено); 
	
	Header   = СвойствоСтруктуры(Данные,"Шапка",Неопределено); 
	ИмяШапки = СвойствоСтруктуры(Данные,"ИмяШапки","header"); 
	
	Если ЗаписьXML=Неопределено тогда
		ЗаписыватьОбъявлениеXML = СвойствоСтруктуры(Данные,"ЗаписыватьОбъявлениеXML",Истина); 
		
		СозданаЗаписьXML = Истина;
	
		ПарамЗаписи = Новый ПараметрыЗаписиXML("UTF-8","1.0"); 
		ЗаписьXML = Новый ЗаписьXML();
		//ЗаписьXML.Параметры = ПарамЗаписи;
		Если не ЗначениеЗаполнено(ИмяФайла)  Тогда
			ЗаписьXML.УстановитьСтроку();
		Иначе	
			ЗаписьXML.ОткрытьФайл(ИмяФайла,ПарамЗаписи);
		КонецЕсли; 
		
		Если ЗаписыватьОбъявлениеXML Тогда
			ЗаписьXML.ЗаписатьОбъявлениеXML();
		КонецЕсли; 
	Иначе	
		СозданаЗаписьXML = Ложь;
	КонецЕсли; 	
	
	ЗаписьXML.ЗаписатьНачалоЭлемента(ИмяШапки);
	Для каждого Эл Из Header Цикл
		ЗаписьXML.ЗаписатьНачалоЭлемента(Эл.Ключ);
		Зн = XMLСтрока(Эл.Значение); 
		ЗаписьXML.ЗаписатьТекст(Зн);
		ЗаписьXML.ЗаписатьКонецЭлемента();
	КонецЦикла; 
	
	Для СЦ=1 по 3  Цикл
		ТЧ = СвойствоСтруктуры(Данные,"ТЧ"+СЦ,Неопределено); 
		Если не ЗначениеЗаполнено(ТЧ)  Тогда
			Продолжить;
		КонецЕсли; 
		ИмяТЧ    = СвойствоСтруктуры(Данные,"ИмяТЧ"+СЦ,"rows"); 
		Если ЗначениеЗаполнено(ИмяТЧ)  Тогда
			ЗаписьXML.ЗаписатьНачалоЭлемента(ИмяТЧ);
		КонецЕсли; 
		ИмяСтрок = СвойствоСтруктуры(Данные,"ИмяСтрок"+СЦ,"row");
		Для каждого Стр Из ТЧ Цикл
			ЗаписьXML.ЗаписатьНачалоЭлемента(ИмяСтрок);
			Для каждого Кол Из ТЧ.Колонки Цикл
				ЗаписьXML.ЗаписатьНачалоЭлемента(Кол.Имя);		
				Зн = XMLСтрока(Стр[Кол.Имя]); 
				ЗаписьXML.ЗаписатьТекст(Зн);
				ЗаписьXML.ЗаписатьКонецЭлемента();
			КонецЦикла;                                                                 
			ЗаписьXML.ЗаписатьКонецЭлемента();
		КонецЦикла;	
		Если ЗначениеЗаполнено(ИмяТЧ)  Тогда
			ЗаписьXML.ЗаписатьКонецЭлемента();
		КонецЕсли;
	КонецЦикла; 
	
	ЗаписьXML.ЗаписатьКонецЭлемента();
	
	Если СозданаЗаписьXML тогда 
		XMLСтрока = ЗаписьXML.Закрыть();
		Возврат XMLСтрока;
	Иначе	
		Возврат  Истина ;
	КонецЕсли; 
КонецФункции

Функция ПолучитьИсполняемыйФайлИзМакетаПутей(ИмяМакета,ПолнИмяИспФайла="",ОбязательноПересоздать=Ложь)  
	ИмяИспФайла = нрег(ИмяМакета) ; 
	Если Не ЗначениеЗаполнено(ПолнИмяИспФайла) Тогда
		ПолнИмяИспФайла = КаталогВременныхФайлов()+ ИмяИспФайла+".exe" ; 
	КонецЕсли;
	ФайлНаДиске = Новый Файл(ПолнИмяИспФайла);
	Если ОбязательноПересоздать или НЕ ФайлНаДиске.Существует() тогда
	 	Макет = ПолучитьОбщийМакет(ИмяМакета);
		Макет.Записать(ПолнИмяИспФайла) ; 
	КонецЕсли;
	возврат  ПолнИмяИспФайла;
КонецФункции
	
#конецесли 

#КонецОбласти 

#Область СерверныеФункцииФормы

#Если НЕ ТонкийКлиент и НЕ ВебКлиент Тогда

// Аналог функции СоздатьКолонки() для обычного приложения
// Если есть поля, созданные интерактивно - их нельзя удалить, но можно скрыть, для этого используется список значений: 
// ИнтерактивныеПоля, где Значение списка - имя элемента форма, Представление: путь к реквизиту, Пометка = Истина - нужно скрыть элемент
Функция СоздатьКолонки(Форма, СоздаваемаяТаблицаЗначений, ИмяРеквизитаФормы, ИмяЭлементаФормы,ИнтерактивныеПоля=Неопределено) экспорт
	Если ИнтерактивныеПоля=Неопределено Тогда
		ИнтерактивныеПоля=новый СписокЗначений;
	КонецЕсли; 
	
	ЭлементТаблица = Форма.Элементы[ИмяЭлементаФормы];
	
	СоответствиеИнтерактивныхРеквизитов = новый Соответствие;
	
	мУдалЭл = новый Массив;
	СписокСущКолонок = ЭлементТаблица.ПодчиненныеЭлементы;
	Для Каждого Колонка Из СписокСущКолонок Цикл
		Эл = ИнтерактивныеПоля.НайтиПоЗначению( Колонка.Имя ); 
		Если Эл = Неопределено Тогда
			мУдалЭл.Добавить(Форма.Элементы.Найти(Колонка.Имя)); 
		Иначе
			СоответствиеИнтерактивныхРеквизитов.Вставить(Эл.Представление,Колонка); 
			Если Эл.Пометка=Истина Тогда // уберем видимость
				//ЭлемФормы = Форма.Элементы.Найти(Колонка.Имя);
				//ЭлемФормы.Видимость=Ложь;
				Колонка.Видимость=Ложь;
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла; 
	Для Каждого Эл из мУдалЭл цикл
		Форма.Элементы.Удалить(Эл);
	КонецЦикла;	
	
	МассивНовыхРеквизитов = Новый Массив;
	МассивУдаляемыхРеквизитов = Новый Массив;
	
	Для Каждого Колонка Из СоздаваемаяТаблицаЗначений.Колонки Цикл
		Если Колонка.ТипЗначения.СодержитТип(Тип("МоментВремени")) Тогда
			Продолжить;
		КонецЕсли;
		Если СоответствиеИнтерактивныхРеквизитов.Получить(ИмяРеквизитаФормы+"."+Колонка.Имя) <> Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		НовыйТип = Новый ОписаниеТипов(Колонка.ТипЗначения,,"Null");
		МассивНовыхРеквизитов.Добавить(Новый РеквизитФормы(Колонка.Имя, НовыйТип, ИмяРеквизитаФормы, Колонка.Заголовок));
	КонецЦикла;
	
	МассивСуществующихРеквизитов = Форма.ПолучитьРеквизиты(ИмяРеквизитаФормы);
	Для Каждого УдаляемыйРеквизит Из МассивСуществующихРеквизитов Цикл
		Если СоответствиеИнтерактивныхРеквизитов.Получить(УдаляемыйРеквизит.Путь+"."+УдаляемыйРеквизит.Имя) <> Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		МассивУдаляемыхРеквизитов.Добавить(УдаляемыйРеквизит.Путь+"."+УдаляемыйРеквизит.Имя);
	КонецЦикла; 
	
	Форма.ИзменитьРеквизиты(МассивНовыхРеквизитов, МассивУдаляемыхРеквизитов);
	//ЗначениеВДанныеФормы(СоздаваемаяТаблицаЗначений, Форма[ИмяРеквизитаФормы]);
	
	ПредвЭлемент = Неопределено;
	МаксИндексКолонок = СоздаваемаяТаблицаЗначений.Колонки.Количество()-1;
	Для СЦ=-МаксИндексКолонок по 0 цикл 
		Колонка = СоздаваемаяТаблицаЗначений.Колонки[-СЦ];
		Если Колонка.ТипЗначения.СодержитТип(Тип("МоментВремени")) Тогда
			Продолжить;
		КонецЕсли; 	
		
		КолонкаИмя = Колонка.Имя;
		ЭлементИмя = ИмяЭлементаФормы + "_" + КолонкаИмя;
		
		ЭлементКолонка = СоответствиеИнтерактивныхРеквизитов.Получить(ИмяРеквизитаФормы+"."+КолонкаИмя); 
		Если ЭлементКолонка=Неопределено тогда // добавим
			ЭлементКолонка = Форма.Элементы.Вставить(ИмяЭлементаФормы + "_" + КолонкаИмя, Тип("ПолеФормы"), ЭлементТаблица, ПредвЭлемент);
			ЭлементКолонка.Вид = ВидПоляФормы.ПолеВвода;
			ЭлементКолонка.ПутьКДанным = ИмяРеквизитаФормы + "." + КолонкаИмя;
		Иначе
			Форма.Элементы.Переместить(ЭлементКолонка,ЭлементТаблица, ПредвЭлемент); 
		КонецЕсли;
		ПредвЭлемент = ЭлементКолонка;
	КонецЦикла; 
	
	Форма[ИмяРеквизитаФормы].Загрузить(СоздаваемаяТаблицаЗначений);

КонецФункции	

#конецесли 

#КонецОбласти 


#Область JSON

////////////////////////////////////////////////////////////////////////////////////////////////////
////  Функции преобразования из json в xml с помощью внешней dll (пока на сервере) //////////// 
////////////////////////////////////////////////////////////////////////////////////////////////////
#Если Сервер Тогда

Функция JSON2XML_DLL(Данные) экспорт	    
	АдресНов = Неопределено;
	Дв = ПолучитьИзВременногоХранилища(Данные.АдресИсточник);
		
	//Рез = ПодключитьВнешнююКомпоненту("d:\jxc_32.dll","jxc", ТипВнешнейКомпоненты.Native,ТипПодключенияВнешнейКомпоненты.НеИзолированно);   
	Рез = ПодключитьВнешнююКомпоненту("ОбщийМакет.jxc","jxc",ТипВнешнейКомпоненты.Native,ТипПодключенияВнешнейКомпоненты.НеИзолированно);
	Если Рез  Тогда
		ОбъектВК = Новый("Addin.jxc.JsonXML1C"); 	
		Дв2 = ОбъектВК.ConvertFromBinaryData(Дв);
		АдресНов = ПоместитьВоВременноеХранилище(Дв2);
	КонецЕсли;
	возврат АдресНов;
КонецФункции	

#конецесли 

////////////////////////////////////////////////////////////////////////////////////////////////////
////  Функции преобразования из json в xml (на клиенте и на сервере, кроме web-клиента) //////////// 
////////////////////////////////////////////////////////////////////////////////////////////////////
#Если НЕ ВебКлиент Тогда
	
Функция JSON2XML(Данные, ИмяКорня="ob", ИмяМассивов="rows", ИмяОбъектов="row") экспорт
	
	Если Найти(Данные,"{")>0 Тогда
		ЭтоФайл = Ложь;
	Иначе
		ЭтоФайл = Истина;
	КонецЕсли; 
	ЧтениеJSON = Новый ЧтениеJSON();
	Если ЭтоФайл Тогда
		ЧтениеJSON.ОткрытьФайл(Данные);
	Иначе	
		ЧтениеJSON.УстановитьСтроку(Данные);
	КонецЕсли; 
	
	Соот = ПрочитатьJSON(ЧтениеJSON,Истина);
	
	СтруктураДанных = новый Структура("ИмяКорня,ИмяМассивов,ИмяОбъектов",ИмяКорня,ИмяМассивов,ИмяОбъектов); 
	
	ЗаписьXML = Новый ЗаписьXML();
	ЗаписьXML.УстановитьСтроку();
	
	Если ЗначениеЗаполнено(ИмяКорня)  Тогда
		ЗаписьXML.ЗаписатьНачалоЭлемента(ИмяКорня);
	КонецЕсли; 
	
	Если ТипЗнч(Соот)=Тип("Соответствие") тогда 
		JSON2XML_Соответствие(Соот,ЗаписьXML, СтруктураДанных); 
	ИначеЕсли ТипЗнч(Соот)=Тип("Массив") тогда 
		JSON2XML_Массив(Соот,ЗаписьXML, СтруктураДанных); 
	КонецЕсли; 	
	
	Если ЗначениеЗаполнено(ИмяКорня)  Тогда
		ЗаписьXML.ЗаписатьКонецЭлемента();
	КонецЕсли;
	
	XMLСтрока = ЗаписьXML.Закрыть();
	
	Возврат XMLСтрока;
	
КонецФункции
	
	
Функция JSON2XML_Массив(Данные, ЗаписьXML, СтруктураДанных) экспорт
	ЗаписьXML.ЗаписатьНачалоЭлемента(СтруктураДанных.ИмяМассивов);
	Н=0;
	Для каждого Эл Из Данные Цикл
		Если ТипЗнч(Эл) = Тип("Массив") тогда
			JSON2XML_Массив(Эл, ЗаписьXML, СтруктураДанных) ;
		ИначеЕсли ТипЗнч(Эл) = Тип("Соответствие") тогда 
			JSON2XML_Соответствие(Эл, ЗаписьXML, СтруктураДанных); 
		Иначе	
			Н=Н+1;
			ЗаписьXML.ЗаписатьНачалоЭлемента(СтруктураДанных.ИмяОбъектов); 
			ЗаписьXML.ЗаписатьАтрибут("pos",Формат(Н,"ЧГ=0"));
			ЗаписьXML.ЗаписатьТекст(XMLСтрока(Эл)); 
			ЗаписьXML.ЗаписатьКонецЭлемента();				
		КонецЕсли; 	
	КонецЦикла; 
	ЗаписьXML.ЗаписатьКонецЭлемента();	
КонецФункции	

Функция JSON2XML_Соответствие(Данные, ЗаписьXML, СтруктураДанных) экспорт
	ЗаписьXML.ЗаписатьНачалоЭлемента(СтруктураДанных.ИмяОбъектов);
	Для каждого Эл Из Данные Цикл
		ЗаписьXML.ЗаписатьНачалоЭлемента(ПреобразоватьКИдентификатору(Эл.Ключ));
		Если ТипЗнч(Эл.Значение) = Тип("Массив") тогда
			JSON2XML_Массив(Эл.Значение, ЗаписьXML, СтруктураДанных) ;
		ИначеЕсли ТипЗнч(Эл.Значение) = Тип("Соответствие") тогда 
			JSON2XML_Соответствие(Эл.Значение, ЗаписьXML, СтруктураДанных); 
		Иначе
			ЗаписьXML.ЗаписатьТекст(XMLСтрока(Эл.Значение)); 
		КонецЕсли; 	
		ЗаписьXML.ЗаписатьКонецЭлемента();	
	КонецЦикла; 
	ЗаписьXML.ЗаписатьКонецЭлемента();	
	
КонецФункции

	
Функция JSON2XML0(Данные, ИмяКорня="ob", ИмяМассивов="rows", ИмяОбъектов="row") экспорт
	
	Если Найти(Данные,"{")>0 Тогда
		ЭтоФайл = Ложь;
	Иначе
		ЭтоФайл = Истина;
	КонецЕсли; 
	ЧтениеJSON = Новый ЧтениеJSON();
	Если ЭтоФайл Тогда
		ЧтениеJSON.ОткрытьФайл(Данные);
	Иначе	
		ЧтениеJSON.УстановитьСтроку(Данные);
	КонецЕсли; 
	
	ЗаписьXML = Новый ЗаписьXML();
	ЗаписьXML.УстановитьСтроку();
	
	Если ЗначениеЗаполнено(ИмяКорня)  Тогда
		ЗаписьXML.ЗаписатьНачалоЭлемента(ИмяКорня);
	КонецЕсли; 
	
	ПришлоСвойство = 0;
	Пока ЧтениеJSON.Прочитать() Цикл
		
		Если ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.НачалоМассива Тогда
			ЗаписьXML.ЗаписатьНачалоЭлемента(ИмяМассивов);
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.НачалоОбъекта Тогда
			ЗаписьXML.ЗаписатьНачалоЭлемента(ИмяОбъектов);
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.КонецОбъекта Тогда
			ЗаписьXML.ЗаписатьКонецЭлемента();
			Если ПришлоСвойство>0 Тогда        //КАО_190524 ТОже надо закрывать 
				ЗаписьXML.ЗаписатьКонецЭлемента(); // закроем свойство
				ПришлоСвойство = макс(ПришлоСвойство-1,0); 
			КонецЕсли; 
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.КонецМассива Тогда
			ЗаписьXML.ЗаписатьКонецЭлемента();
			Если ПришлоСвойство>0 Тогда
				ЗаписьXML.ЗаписатьКонецЭлемента(); // закроем свойство
				ПришлоСвойство = макс(ПришлоСвойство-1,0); 
			КонецЕсли; 
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.ИмяСвойства Тогда
			ЗаписьXML.ЗаписатьНачалоЭлемента(ПреобразоватьКИдентификатору(ЧтениеJSON.ТекущееЗначение));
			ПришлоСвойство = ПришлоСвойство + 1;
		Иначе
			//Если ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.Булево
			//или ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.Число
			//или ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.Строка Тогда
			//
			//	Если ТипЗнч(ЧтениеJSON.ТекущееЗначение) = Тип("Число") Тогда
			//		ЗаписьXML.ЗаписатьТекст(Формат(ЧтениеJSON.ТекущееЗначение, "ЧГ=0"));
			//	Иначе
			//		ЗаписьXML.ЗаписатьТекст(Строка(ЧтениеJSON.ТекущееЗначение));
			//	КонецЕсли;
			//КонецЕсли; 	
			
			//КАО_180710 Можно просто записывать как XMLСтрока
			ЗаписьXML.ЗаписатьТекст(XMLСтрока(ЧтениеJSON.ТекущееЗначение)); 
			
			ЗаписьXML.ЗаписатьКонецЭлемента();
			ПришлоСвойство = макс(ПришлоСвойство-1,0); 
		КонецЕсли;
	КонецЦикла;
	
	Если ЗначениеЗаполнено(ИмяКорня)  Тогда
		ЗаписьXML.ЗаписатьКонецЭлемента();
	КонецЕсли;
	
	XMLСтрока = ЗаписьXML.Закрыть();
	
	Возврат XMLСтрока;
	
КонецФункции

Функция JSON2XML1(Данные, ИмяКорня="ob", ИмяМассивов="rows", ИмяОбъектов="row") экспорт
	
	Если Найти(Данные,"{")>0 Тогда
		ЭтоФайл = Ложь;
	Иначе
		ЭтоФайл = Истина;
	КонецЕсли; 
	ЧтениеJSON = Новый ЧтениеJSON();
	Если ЭтоФайл Тогда
		ЧтениеJSON.ОткрытьФайл(Данные);
	Иначе	
		ЧтениеJSON.УстановитьСтроку(Данные);
	КонецЕсли; 
	
	СтруктураДанных = новый Структура("ИмяКорня,ИмяМассивов,ИмяОбъектов",ИмяКорня,ИмяМассивов,ИмяОбъектов); 
	
	ЗаписьXML = Новый ЗаписьXML();
	ЗаписьXML.УстановитьСтроку();
	
	Если ЗначениеЗаполнено(ИмяКорня)  Тогда
		ЗаписьXML.ЗаписатьНачалоЭлемента(ИмяКорня);
	КонецЕсли; 
	
	ПришлоСвойство  = 0;
	Пока ЧтениеJSON.Прочитать() Цикл
		
		Если ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.НачалоМассива Тогда
			ЗаписьXML.ЗаписатьНачалоЭлемента(ИмяМассивов);
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.НачалоОбъекта Тогда
			ЗаписьXML.ЗаписатьНачалоЭлемента(ИмяОбъектов);
			JSON2XML_R(ЧтениеJSON,ЗаписьXML,СтруктураДанных);  
			ЗаписьXML.ЗаписатьКонецЭлемента();
			//Если ПришлоСвойство=0 Тогда
			//КонецЕсли ;	
			//Если ПришлоСвойство>0 Тогда
			//	//ПришлоСвойство1 = ПришлоСвойство1 + 1;
			//КонецЕсли;  
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.КонецОбъекта Тогда
			ЗаписьXML.ЗаписатьКонецЭлемента();
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.КонецМассива Тогда
			попытка
			ЗаписьXML.ЗаписатьКонецЭлемента();
			исключение
			конецпопытки;
			Если ПришлоСвойство>0 тогда
				ЗаписьXML.ЗаписатьКонецЭлемента(); // закроем свойство
				ПришлоСвойство = макс(ПришлоСвойство-1,0); 
			КонецЕсли; 
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.ИмяСвойства Тогда
			ИмяСвойства = ЧтениеJSON.ТекущееЗначение;
			ЗаписьXML.ЗаписатьНачалоЭлемента(ПреобразоватьКИдентификатору(ИмяСвойства));
			ПришлоСвойство = ПришлоСвойство + 1;
		Иначе
			Если ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.Булево
			или ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.Число
			или ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.Строка Тогда
			
				//Если ТипЗнч(ЧтениеJSON.ТекущееЗначение) = Тип("Число") Тогда
				//	ЗаписьXML.ЗаписатьТекст(Формат(ЧтениеJSON.ТекущееЗначение, "ЧГ=0"));
				//Иначе
				//	ЗаписьXML.ЗаписатьТекст(Строка(ЧтениеJSON.ТекущееЗначение));
				//КонецЕсли;
				
				//КАО_180710 Можно просто записывать как XMLСтрока
				ЗаписьXML.ЗаписатьТекст(XMLСтрока(ЧтениеJSON.ТекущееЗначение)); 
				
			КонецЕсли; 	

			ЗаписьXML.ЗаписатьКонецЭлемента();
			ПришлоСвойство = макс(ПришлоСвойство-1,0); 
		КонецЕсли;
	КонецЦикла;
	
	Если ЗначениеЗаполнено(ИмяКорня)  Тогда
		ЗаписьXML.ЗаписатьКонецЭлемента();
	КонецЕсли;
	
	XMLСтрока = ЗаписьXML.Закрыть();
	
	Возврат XMLСтрока;
	
КонецФункции


Функция JSON2XML_R(ЧтениеJSON, ЗаписьXML, СтруктураДанных) 
	
	ПришлоСвойство  = 0;
	Пока ЧтениеJSON.Прочитать() Цикл
		
		Если ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.НачалоМассива Тогда
			ЗаписьXML.ЗаписатьНачалоЭлемента(СтруктураДанных.ИмяМассивов);
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.НачалоОбъекта Тогда
			//ЗаписьXML.ЗаписатьНачалоЭлемента(СтруктураДанных.ИмяОбъектов);
			//JSON2XML_R(ЧтениеJSON, ЗаписьXML, СтруктураДанных); 
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.КонецОбъекта Тогда
			//ЗаписьXML.ЗаписатьКонецЭлемента();
			возврат  Истина ; 
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.КонецМассива Тогда
			попытка
			ЗаписьXML.ЗаписатьКонецЭлемента();
			исключение
			конецпопытки;
			Если ПришлоСвойство>0 тогда
				ЗаписьXML.ЗаписатьКонецЭлемента(); // закроем свойство
				ПришлоСвойство = макс(ПришлоСвойство-1,0); 
			КонецЕсли; 
		ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.ИмяСвойства Тогда
			ИмяСвойства = ЧтениеJSON.ТекущееЗначение;
			ЗаписьXML.ЗаписатьНачалоЭлемента(ПреобразоватьКИдентификатору(ИмяСвойства));
			ПришлоСвойство = ПришлоСвойство + 1;
		Иначе
			Если ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.Булево
			или ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.Число
			или ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.Строка Тогда
			
				//Если ТипЗнч(ЧтениеJSON.ТекущееЗначение) = Тип("Число") Тогда
				//	ЗаписьXML.ЗаписатьТекст(Формат(ЧтениеJSON.ТекущееЗначение, "ЧГ=0"));
				//Иначе
				//	ЗаписьXML.ЗаписатьТекст(Строка(ЧтениеJSON.ТекущееЗначение));
				//КонецЕсли;
				
				//КАО_180710 Можно просто записывать как XMLСтрока
				ЗаписьXML.ЗаписатьТекст(XMLСтрока(ЧтениеJSON.ТекущееЗначение)); 
				
			КонецЕсли; 	
			
			ЗаписьXML.ЗаписатьКонецЭлемента();
			ПришлоСвойство = макс(ПришлоСвойство-1,0); 
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции


#КонецЕсли 

#КонецОбласти 

#Область ЗначенияПоУмолчанию


// Функция - Заполнить значения по умолчанию
//
// Параметры:
//  ТЗ									 - ТаблицаЗначений	 - обрабатываемая ТЗ
//  ЗначенияПоУмолчанию	 - Соответствие	 - Соответствие для заполнения значений, ключ - имя колонки, значение - реальное значение или специальный код 
//    Код для заполнения значений по умолчанию: 
//      Если в значении соответствия есть префикс "@" - считаем, что это имя колонки (например, @Цена - значение брется из колонки Цена)  
//      Если в значении соответствия есть префикс "=" - считаем, что можно использовать функцию Вычислить, текущая строка - "Стр", таблица значений "ТЗ" (например, '=Стр.Цена*Стр.Количество')  
//      Если в значении соответствия есть строка "Результат=" - считаем, что можно использовать оператор Выполнить, текущая строка - "Стр", таблица значений "ТЗ" (например, 'Курс = ПулучитьКурс(); Результат=Стр.Цена*Курс;')  
// 			Можно использовать функции ДатаИзСтроки, ЧислоИзСтроки     
// Возвращаемое значение:
//  Булево - Истина - таблица обработана успешно
//
Функция ЗаполнитьЗначенияПоУмолчанию(ТЗ, ЗначенияПоУмолчанию) экспорт
	Если ЗначенияПоУмолчанию.Количество()=0 Тогда
		возврат  Истина ;
	КонецЕсли; 
	Если не ЗначениеЗаполнено(ТЗ)  Тогда
		возврат  Истина ;
	КонецЕсли; 
	НовЗначенияПоУмолчанию = новый Соответствие(); 
	Для каждого Эл Из ЗначенияПоУмолчанию Цикл
		Если ТЗ.Колонки.Найти(Эл.Ключ)=Неопределено Тогда // колонки еще не было - можем добавить
			ТЗ.Колонки.Добавить(Эл.Ключ); 	
			//ТЗ.ЗаполнитьЗначения(Эл.Значение,Эл.Ключ);
		//Иначе // колонка уже была - нужно пробежать по ТЗ и установить значения, там где не было 	
		КонецЕсли; 	
		НовЗначенияПоУмолчанию.Вставить(Эл.Ключ,Эл.Значение); 
	КонецЦикла; 
	Если НовЗначенияПоУмолчанию.Количество()=0 Тогда
		возврат  Истина ; // уже все обработано
	КонецЕсли; 
	
	Для каждого Стр Из ТЗ Цикл 
		Для каждого Эл Из НовЗначенияПоУмолчанию Цикл
			Если НЕ ЗначениеЗаполнено(Стр[Эл.Ключ])  Тогда
				Если ТипЗнч(Эл.Значение)=Тип("Строка") И Лев(Эл.Значение,1)="@" Тогда // имя колонки
					ИмяИсхКолонки = СокрЛП(Сред(Эл.Значение,2)); 
					Стр[Эл.Ключ] = Стр[ИмяИсхКолонки];
				ИначеЕсли ТипЗнч(Эл.Значение)=Тип("Строка") И Лев(Эл.Значение,1)="=" Тогда // вычислить
					Попытка
						Код = СокрЛП(Сред(Эл.Значение,2)); 
						Результат = Вычислить(Код); 
						Стр[Эл.Ключ] = Результат;
					Исключение
					  Стр[Эл.Ключ] = Неопределено;
					КонецПопытки; 
				ИначеЕсли ТипЗнч(Эл.Значение)=Тип("Строка") И (Найти(нрег(Эл.Значение),"результат=")>0 или Найти(нрег(Эл.Значение),"результат =")>0) Тогда // выполнить
					Попытка
						Код = Эл.Значение; 
						Результат = Неопределено ;
						Выполнить(Код); 
						Стр[Эл.Ключ] = Результат;
					Исключение
					  Стр[Эл.Ключ] = Неопределено;
					КонецПопытки; 
				Иначе	
					Стр[Эл.Ключ] = Эл.Значение;
				КонецЕсли; 
			КонецЕсли; 
		КонецЦикла;; 
	КонецЦикла;  
	возврат  Истина ;	
КонецФункции

#КонецОбласти 